{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "02fd5618_b6e6c5f6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-19T22:19:14Z",
      "side": 1,
      "message": "Addressed and replied to your comments. Thanks",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c63c2557_3a2dbbac",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:15:45Z",
      "side": 1,
      "message": "I\u0027m pretty confused why this isn\u0027t just a bool, and this description in the documentation doesn\u0027t help me understand at all.\n\nI think the intent is better met with something like\n\nUpperCriticalThreshold: double\nUpperCriticalAsserted: bool\nUpperWarningThreshold: Double\nUpperWarningAsserted: bool\n\nif we\u0027re now putting all the thresholds in one interface.  As written, I suspect you\u0027ve mostly just recreated the Properties interface (which already can return a dict of propertyname, value.)",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4772c4ff_b94b00f2",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-20T18:44:36Z",
      "side": 1,
      "message": "We then have to create 10 (now) properties and probably more as someone adds new threshold names.  I suspect most metrics/sensors only use ~4 threshold levels.\n\nWe also have to define a way to indicate \"this threshold doesn\u0027t exist\".  The current way we do that was using NaN, which we were told that wasn\u0027t desirable...  So, Jagpal went with this explicit dictionary.",
      "parentUuid": "c63c2557_3a2dbbac",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ed108f9_fce04240",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-20T19:21:59Z",
      "side": 1,
      "message": "\u003e We then have to create 10 (now) properties and probably more as someone adds new threshold names.  I suspect most metrics/sensors only use ~4 threshold levels.\n\nI agree, and would really expect most sensors only use 2 levels (warning and critical) because that was all that existed for a long time.\n\nSure, you\u0027d have to add a property for every new level, but in the current method to add an additional level, you still have to add the enum, so it\u0027s not like it saves us a code review/update all the daemons round, or lets us support arbitrary level names as written.  I guess I just don\u0027t see the advantage of making it more complex.\n\n\u003e \n\u003e We also have to define a way to indicate \"this threshold doesn\u0027t exist\".  The current way we do that was using NaN, which we were told that wasn\u0027t desirable...  So, Jagpal went with this explicit dictionary.\n\nThe problem wasn\u0027t directly with NAN it was that it was one of two ways to represent that a property wasn\u0027t filled;  You could represent a non-existent threshold by simply omiting the interface itself, or omitting one of two properties, or setting one of two properties to NAN, or setting both properties to NAN.  Handling all those cases was a pain.  This interface smashes all thresholds into one interface, which solves that problem, regardless of whether a map is used, because NAN can just be used directly, and there\u0027s no other way to represent properties non-existence.\n\nA map in a property is a pain to use because this interface now doesn\u0027t\u0027 look like anything else, so in most code, you end up now having to pull the individual parameters out in custom to thresholds code.  There\u0027s already a lot of code that can pull out an interface of named properties, so making it look like a bunch of properties on one interface means we\u0027re not doing something special for thresholds.\n\nThe other advantage of using properties is that you can have implementations that change thresholds at runtime.  Property.Set can be used to update a single threshold.  As written you\u0027d have a do a read-\u003emodify-\u003ewrite, which isn\u0027t easy to handle in code, and has data races if the data is updated in between a read and a write.",
      "parentUuid": "4772c4ff_b94b00f2",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a91f48fc_349768f4",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "As i understand the main point of discussion is on having \"named properties vs generic container for properties\" as proposed. \nI would take a step back and try to understand the issues with the existing threshold interface. My understanding - it was something to do with usage of Nan for properties which didn\u0027t exist as interfaces were defining concrete properties. Hence, as solution to that problem we proposed is this generic container type interface rather than concrete properties and moved all those types into one interface. But as i see now above from Ed\u0027s comment he was more concerned about having different methods to define the non-existent properties rather than just not defining them at all. Some of this has been solved through collapsing 5 interface files into one.\n\nNow, if we converge on \"named properties vs generic container for properties\", the next is we can define a standard way to represent non-existent properties.\n\n@Patrick,\nAre you on board with named properties based on easy match expression reasoning given by Ed?\n\n@Ed,\nIs there any other issue/limitations with the existing interface that we need to consider?\nIn relation to data races, these properties are going to set once at start time and shouldn\u0027t change as they are read from platform configuration, unless there is a plan to change that to make them writable at runtime?",
      "parentUuid": "8ed108f9_fce04240",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e0a0803_9140b56c",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-21T20:00:31Z",
      "side": 1,
      "message": "I\u0027m not totally buying the match-ease as the reason to use individual properties.  argN is the match statement for ensuring that specific fields in the signal match a desired value.  It\u0027s not really hard to match { Critical, Upper } if that\u0027s what you want to do.\n\nThis map turns into a map in C++ also.  Doing a lookup is not really any more work than reading an individual property.  It\u0027s also easier to iterate on a map than it is individual properties.  (If someone wants to operate / look through multiple thresholds, they end up having to unroll-the-loop by hand with the individual property method, but they can just do a map-lookup with the map case.)",
      "parentUuid": "a91f48fc_349768f4",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f55b0043_dcef3804",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T20:20:34Z",
      "side": 1,
      "message": "From coding perspective, i agree it may be easier with using map rather than named properties.",
      "parentUuid": "0e0a0803_9140b56c",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8710ca64_3f1d77ba",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-21T21:02:30Z",
      "side": 1,
      "message": "\u003e I\u0027m not totally buying the match-ease as the reason to use individual properties.\n\nWe have sdbusplus library code that can parse out named properties into their individual named components (sdbusplus::unpackPropertiesNoThrow).  So far as I\u0027m aware, we don\u0027t have an equivalent for map\u003cstring, string\u003e.  Maybe I\u0027m mistaken or there\u0027s an existing example that does something like this?  The only example I know of that\u0027s similar to this is User.Manager.GetUserInfo, and maintaining it has been a mess because it\u0027s an array of structs.  I\u0027m trying to avoid a similar complexity here.\n\n\u003e This map turns into a map in C++ also. \n\nFYI, I don\u0027t think there\u0027s anywhere left that turns DBus properties into a std::map anymore in bmcweb, so it\u0027s not really \"also\" in that context.  Basically everywhere we do it, we\u0027re iterating a vector in O(n) time these days, because the actual \"map\" never really mattered, given we know the structure upfront.\n\nIf this is properties, it looks like:\n\n```\ndouble upperWarning \u003d 0.0;\nbool upperWarningAsserted \u003d false;\ndouble upperCritical \u003d 0.0;\n\u003crest of the properties\u003e\n\nbool success \u003d sdbusplus::unpackPropertiesNoThrow(\n    dbus_utils::UnpackErrorPrinter(), ret, \"UpperWarning\", upperWarning, \"UpperWarningAsserted\", upperWarningAsserted,\n    \"UpperCritical\", upperCritical... etc);\n```\n\nAnd is much simpler than the equivalent\n\n\n```\nstd::vector\u003cstd::pair\u003cstd::string, std::tuple\u003cstd::string, std::string, double\u003e \u003e\u003e thresholds;\n\nbool success \u003d sdbusplus::unpackPropertiesNoThrow(\n    dbus_utils::UnpackErrorPrinter(), ret, \"Value\", value);\n\nstd::optional\u003cdouble\u003e upperCritical \u003d 0.0;\nstd::optional\u003cdouble\u003e upperWarning \u003d 0.0;\n\nfor threshold in thresholds:\n    if (std::get\u003c0\u003e(threshold.second) \u003d\u003d \"xyz.openbmc_proejct.Common.threshold.Critical\" \u0026\u0026 \n        std::get\u003c1\u003e(threshold.second) \u003d\u003d \"xyz.openbmc_project.Common.Threshold.Bound.Upper\"){\n            upperBound \u003d std::get\u003c2\u003e(threshold.second);\n    }\n    else if (std::get\u003c0\u003e(threshold.second) \u003d\u003d \"xyz.openbmc_proejct.Common.threshold.Warning\" \u0026\u0026 \n        std::get\u003c1\u003e(threshold.second) \u003d\u003d \"xyz.openbmc_project.Common.Threshold.Bound.Upper\"){\n            upperWarning \u003d std::get\u003c2\u003e(threshold.second);\n    }\n    ..... \n    ...\n    {\n        Handle non-existent property.\n        Return;\n    }\n\nif (upperCritical){\n    Treshold present\n}\n...\n```\n\nWith all of the above said, if patchsets exist that show that there\u0027s a way to write this that isn\u0027t a mess of error handling to use a map, and we can have a similar amount of code using a map while still handling errors properly, I\u0027m happy to be proven wrong, it just doesn\u0027t track in my head, having seen implementations of both, and given the above examples.",
      "parentUuid": "f55b0043_dcef3804",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02a56c18_7ef09d47",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-21T21:06:39Z",
      "side": 1,
      "message": "\u003e they end up having to unroll-the-loop by hand with the individual property method\n\nGiven that Dbus is its own spec, and invents interfaces in addition to and not exactly matching the Redfish spec, we have to unroll the loop by hand anyway to map X in Dbus means Y in Redfish.",
      "parentUuid": "8710ca64_3f1d77ba",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2723f17_6179a9af",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-21T21:37:56Z",
      "side": 1,
      "message": "I\u0027m not sure we should be making arguments about the complexity or lack-there-of for code that goes out of its way to avoid using the generated bindings.\n\nsdbusplus (and the phosphor-dbus-interface headers) can turn this property into a map of enums, not even strings.\n\nThis is the generated async client binding:\n```\n    auto value()\n    {\n        return proxy.template get_property\u003cstd::map\u003cstd::tuple\u003cType, Bound\u003e, double\u003e\u003e(context(), \"Value\");\n    }\n```\n\nAs you see, it turns into a `map\u003ctuple\u003cType, Bound\u003e, double\u003e`, which is exactly what you\u0027d expect from the interface definition here.\n\nSince the message pack/unpack code is common, I don\u0027t even see any reason why this wouldn\u0027t work with the ASIO unpackPropertiesNoThrow code (ie. the existing unpackProperties can handle either vector/map of the C++ enum values; this works today without even converting to the async co-routines support).\n\nAs far as iteration goes, if you don\u0027t want to use the bindings or map you\u0027d end up with something like this:\n\n```\nvector\u003ctuple\u003cstring, string\u003e, double\u003e value;\nsdbusplus::unpackPropertiesNoThrow(... \"Value\", value);\n\nconstexpr auto jsonMap \u003d { \n   { \"UpperCritical\", { \"xyz...Critical\", \"xyz...Upper\" } },\n   { \"UpperWarning\", { \"xyz...Warning\", \"xyz...Upper\" } },\n};\n\nfor (auto\u0026 [j, t] : jsonMap)\n{\n    if (value.contains(t))\n    {\n        json[j] \u003d value[t];\n    }\n    else\n    {\n        // Handle non-existent property.\n    }\n}\n```\n\nYour unpack-all-the-properties-at-once example doesn\u0027t handle NaN, which is yet another set of loop unrolling and if-conditions.  I don\u0027t see that example as shorter / better / more succinct than this constexpr-loop.",
      "parentUuid": "02a56c18_7ef09d47",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fa5d29a_b047db6b",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-22T04:31:24Z",
      "side": 1,
      "message": "\u003e I\u0027m not sure we should be making arguments about the complexity or lack-there-of for code that goes out of its way to avoid using the generated bindings.\n\n\u003e \n\u003e sdbusplus (and the phosphor-dbus-interface headers) can turn this property into a map of enums, not even strings.\n\u003e \n\u003e This is the generated async client binding:\n\u003e ```\n\u003e     auto value()\n\u003e     {\n\u003e         return proxy.template get_property\u003cstd::map\u003cstd::tuple\u003cType, Bound\u003e, double\u003e\u003e(context(), \"Value\");\n\u003e     }\n\u003e ```\n\u003e \n\u003e As you see, it turns into a `map\u003ctuple\u003cType, Bound\u003e, double\u003e`, which is exactly what you\u0027d expect from the interface definition here.\n\nUnless this proposal is saying that bmcweb should take the generated bindings, or is proposing creating a new webserver that someone is going to maintain, or is going to exclusively use projects that make use of the generated bindings, then I\u0027m not sure who the above helps.  I think the new async bindings are great, and have the potential to make code a lot cleaner with fewer bugs, but I\u0027m not sure how they matter in the context of this review.\n\n\u003e \n\u003e Since the message pack/unpack code is common, I don\u0027t even see any reason why this wouldn\u0027t work with the ASIO unpackPropertiesNoThrow code (ie. the existing unpackProperties can handle either vector/map of the C++ enum values; this works today without even converting to the async co-routines support).\n\n\nThe enums vs strings don\u0027t really end up helping much in my experience, because we have to handle errors where the enum didn\u0027t exist without throwing and exception through the executor that we can\u0027t handle.  You\u0027re right, you can unpack as std::map (which bmcweb used to do heavily) but in practice it didn\u0027t really save code versus just unpacking as a string.\n\n\u003e \n\u003e As far as iteration goes, if you don\u0027t want to use the bindings or map you\u0027d end up with something like this:\n\u003e \n\u003e ```\n\u003e vector\u003ctuple\u003cstring, string\u003e, double\u003e value;\n\u003e sdbusplus::unpackPropertiesNoThrow(... \"Value\", value);\n\u003e \n\u003e constexpr auto jsonMap \u003d { \n\u003e    { \"UpperCritical\", { \"xyz...Critical\", \"xyz...Upper\" } },\n\u003e    { \"UpperWarning\", { \"xyz...Warning\", \"xyz...Upper\" } },\n\u003e };\n\u003e \n\u003e for (auto\u0026 [j, t] : jsonMap)\n\u003e {\n\u003e     if (value.contains(t))\n\u003e     {\n\u003e         json[j] \u003d value[t];\n\u003e     }\n\u003e     else\n\u003e     {\n\u003e         // Handle non-existent property.\n\u003e     }\n\u003e }\n\u003e ```\n\u003e \n\u003e Your unpack-all-the-properties-at-once example doesn\u0027t handle NaN, which is yet another set of loop unrolling and if-conditions.  I don\u0027t see that example as shorter / better / more succinct than this constexpr-loop.\n\nYep, but handling Nan already has to be a branch either way.  I didn\u0027t mean to make them seem different.  Your example still would be more code I think?\n\nI can\u0027t say I agree with the single property, and that\u0027s ok.  We had code that looked a lot like what you have above a while ago, and it caused pretty significant bugs and was hard to maintain.  value.contains() for example lets people typo Enum value namespaces, or ignore the enum namespace.  My preference is still for explicit properties, because the handling is simpler, the tooling and CLIs handles properties already, and you don\u0027t have the read-modify-write problem to cover.",
      "parentUuid": "a2723f17_6179a9af",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8a4ec88_c5b7eb13",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1000945
      },
      "writtenOn": "2023-10-08T22:47:27Z",
      "side": 1,
      "message": "Can someone explain why we don\u0027t support the `Fatal` threshold type in OpenBMC? Behind warning/critical sensor also have `fatal` threshold right?",
      "parentUuid": "5fa5d29a_b047db6b",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08b4b5f4_5b3e9618",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 12,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-10-17T21:27:04Z",
      "side": 1,
      "message": "@Thu,\nI discussed with Patrick on this. You can say that critical is same as fatal as actions performed at the critical level are the last resort. Or in other words they would just be synonyms.",
      "parentUuid": "b8a4ec88_c5b7eb13",
      "range": {
        "startLine": 12,
        "startChar": 10,
        "endLine": 12,
        "endChar": 66
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b4978cc_d6de249f",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T21:33:01Z",
      "side": 1,
      "message": "nit: I\u0027m not positive if we want \u0027const\u0027 or \u0027readonly\u0027 for this.  \u0027const\u0027 means you can\u0027t change the value, even internally, and no signals will be emitted.  I can conceive of implementations that might want to adjust metric thresholds based on other activity.\n\nThis is probably fine to leave as-is for now or change to readonly now.  We can easily change this flag in the future.",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cf9225a9_4649a87b",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-19T22:19:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3b4978cc_d6de249f",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b93eeca6_77827704",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T21:33:01Z",
      "side": 1,
      "message": "Why is this an array?  We can\u0027t be over the Upper and under the Lower at the same time, right?\n\nSuppose we already had Critical-Upper asserted and we, in one polling interval, switch to Warning-Lower.  I would expect 2 signals: one to deassert the Critical-Upper and one to assert the Warning-Lower.",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fde93d18_8bf79467",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-19T22:19:14Z",
      "side": 1,
      "message": "This indicates the upper bound and lower bound (range) for the threshold level. Also, there is no Critical-Upper, there is just Critical, Upper bound and lower bound just defines the range for each threshold level.\n\nOther way to get this info would be to query the threshold interface using the ThresholdType from signal parameters. Let me know if you think thats better rather than sending it as part of signal?",
      "parentUuid": "b93eeca6_77827704",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6b08246_f971323c",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T22:29:33Z",
      "side": 1,
      "message": "I don‚Äôt really understand the utility of that. It means I have to pick apart this array and do math based on Value from the signal in order to know what‚Äôs going on. I suspect typical usage is going to be:\n\n‚ÄúI see that Critical Upper is now asserted‚Äù and do some reaction to that. Having the value in the signal is extra gravy.  \n\nAsking the consumer to do math from the signal values to know what is going on is going to end up with some boilerplate code copied around in order to reverse this information back out of the signal.",
      "parentUuid": "fde93d18_8bf79467",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7da4b683_9d4aae81",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T22:31:20Z",
      "side": 1,
      "message": "I would suggest changing this to just a Bound property.  If someone needs the ranges they can read that property.  We don‚Äôt need to send it along in each signal.",
      "parentUuid": "e6b08246_f971323c",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8d46f9e_48533b3a",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T22:59:33Z",
      "side": 1,
      "message": "Also, while we are making a change, let\u0027s change the order in the signal.\n\n1. Type\n2. Bounds\n3. Status\n4. Value",
      "parentUuid": "7da4b683_9d4aae81",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0680e1e6_46ef1d8c",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-19T23:00:34Z",
      "side": 1,
      "message": "Having this signal param provides the user the upper and lower bound for the threshold assertion. My understanding is it has no special value but just extra info, it was there in original Threshold specification, but yes, user can query the threshold interface to get these bounds.\n\nThe bounds already exist in threshold interface as part of Value property. So, would just drop this.",
      "parentUuid": "7da4b683_9d4aae81",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c650871b_8e465084",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:15:45Z",
      "side": 1,
      "message": "\u003e Having this signal param provides the user the upper and lower bound for the threshold assertion. \n\nIs there anything that requires both the upper and lower bounds on an assertion of a single?  In the past, what\u0027s been required is:\n\nThe name and direction of the threshold we crossed (ideally they\u0027d be combined).\nWhether or not the threshold got asserted or deasserted\nThe value that the sensor read that crossed the value.\n\nAnything else is just kind of inventing complexity IMO.\n\n\nOverall, I suspect this interface would be a lot simpler with defining 10 signals:\nWarningAsserted\nWarningDeasserted\nCriticalAsserted\nCriticalDeasserted\n.....\n\nwith each signal only containing the value that caused the crossing.  Making dictionaries of these things seems like a good idea, but really messes with the ability to define DBus match expressions properly.  For example, on the interface you published, try to write a match that only fires when and upper critical threshold is posted.  Even if you could do it, it\u0027s going to be complicated.  Versus if the threshold is a named Property, it\u0027s significantly easier, you can just match on the interface name and member.",
      "parentUuid": "0680e1e6_46ef1d8c",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58a65186_be3aff0d",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 41,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "@Patrick,\nAdded the bounds to signal and changed the order of properties.\n\n@Ed,\nYes, thats what the signal should report. You can refer to latest commit update.\n\nFor having named vs generic properties, we already have another comment above. Once we conclude on that, we can absorb that change at other places as well. So, lets discuss on that comment thread. Resolving this one.",
      "parentUuid": "c650871b_8e465084",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b51ace8d_f14783bd",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:15:45Z",
      "side": 1,
      "message": "?????  What does a \"none\" level represent?  \"None\" is already effectively handled by just omitting the interface.",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2104d48a_3ba50cf3",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-20T18:44:36Z",
      "side": 1,
      "message": "I suspect this was needed so that the Asserted property could indicate None?",
      "parentUuid": "b51ace8d_f14783bd",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b711308b_504701c6",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-20T19:21:59Z",
      "side": 1,
      "message": "Why would a threshold level be \"none\"?  At a minimum, the description doesn\u0027t call out what it represents, given it\u0027s non-obvious based on the name. At most, I suspect there\u0027s no reason for this to exist and could be removed.",
      "parentUuid": "2104d48a_3ba50cf3",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c6d7bee_1b7b0fa0",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-20T19:25:10Z",
      "side": 1,
      "message": "Ok, I re-read your comment, and I think I get it.  The Asserted property itself being one property is why this is odd, given that it\u0027s very likely that multiple thresholds are asserted at a time (generally a critical threshold would imply an asserted Warning, but that isnt\u0027 called out or specified);  I suspect when we come to conclusion on the other comment about separating out the properties, this will be solved at the same time.",
      "parentUuid": "b711308b_504701c6",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bd7f9eb_a1bd38c5",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "My understanding is that at any particular time we have only one threshold asserted. So, lets say we were in warning and the value increased to critical range. We will de-assert warning and assert critical because now value is out of warning range and falls in critical range. Please correct me if i am wrong?",
      "parentUuid": "6c6d7bee_1b7b0fa0",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d04944d8_3cc66baf",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-21T21:02:30Z",
      "side": 1,
      "message": "\u003e My understanding is that at any particular time we have only one threshold asserted.\n\nThis generally isn\u0027t true in the existing interfaces, and as you\u0027ve written is going to enforce constraints like \"upper Warning is always below upper critical\", and corner cases, like what happens when Critical and PerformanceLoss are the same value.  Given that most of the time these are user-settable values, there can exist cases where warning is higher than critical (even if it\u0027s only as it\u0027s being set) that I don\u0027t think this interfaces documents the interactions of sufficiently, and frankly, I don\u0027t think it\u0027s worth making an interface that needs documented to that level.\n\nI really think just asserting/deasserting each threshold separately will be simpler, and have fewer corners that would need documented in this interface.\n\nFWIW, Redfish and IPMI both separate out thresholds into separate properties/struct fields.  I don\u0027t know of any that publish a single \"current threshold assertion level\"",
      "parentUuid": "4bd7f9eb_a1bd38c5",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec7248f7_7079f1ea",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-10-18T12:31:07Z",
      "side": 1,
      "message": "üëç",
      "parentUuid": "d04944d8_3cc66baf",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd6fd3f0_4ed0cd18",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-10-22T05:58:24Z",
      "side": 1,
      "message": "Done.\n\nRemoved the None level as discussed above and changed the asserted thresholds to an array.",
      "parentUuid": "ec7248f7_7079f1ea",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 52,
        "endChar": 37
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d39c995_4b45d6a6",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:15:45Z",
      "side": 1,
      "message": "nit, typo.",
      "range": {
        "startLine": 64,
        "startChar": 35,
        "endLine": 64,
        "endChar": 43
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ae93db6_e3b59a46",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3d39c995_4b45d6a6",
      "range": {
        "startLine": 64,
        "startChar": 35,
        "endLine": 64,
        "endChar": 43
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a49a1e2_957bbcf0",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 70,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:15:45Z",
      "side": 1,
      "message": "the range would generally be a numerical value, I suspect this needs to be changed to \"direction\"\n\nAlso, the way you\u0027ve phrased this makes it really sound like you\u0027re handling hysteresis, when upper/lower is generally used to represent whether it\u0027s a high critical or a low critical.",
      "range": {
        "startLine": 70,
        "startChar": 39,
        "endLine": 70,
        "endChar": 44
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17ca1ae5_b59e772e",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 70,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a49a1e2_957bbcf0",
      "range": {
        "startLine": 70,
        "startChar": 39,
        "endLine": 70,
        "endChar": 44
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ac49338_6580ba42",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 78,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:15:45Z",
      "side": 1,
      "message": "Do we need to publish the hysteresis on any of these?  I forget if it\u0027s on the old one.  If it\u0027s not in the old one, it\u0027s fine to omit here.",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2b094ef_eb24bfb5",
        "filename": "yaml/xyz/openbmc_project/Common/Threshold.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 78,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0ac49338_6580ba42",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3d82769_791e6475",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 3,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T21:33:01Z",
      "side": 1,
      "message": "nit: I\u0027m not sure if this is interesting information.  It could change in the future.",
      "range": {
        "startLine": 2,
        "startChar": 63,
        "endLine": 3,
        "endChar": 56
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa6b5ae3_612484c6",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 3,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-19T22:19:14Z",
      "side": 1,
      "message": "Done, removed specific examples.",
      "parentUuid": "b3d82769_791e6475",
      "range": {
        "startLine": 2,
        "startChar": 63,
        "endLine": 3,
        "endChar": 56
      },
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2ccbc6c_3ef16a21",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-19T23:17:48Z",
      "side": 1,
      "message": "Generally in telemetry it\u0027s better if all counters don\u0027t support an explicit reset, and clients rely on the count incrementing as being an event.  This avoids problems in architecture where one client might reset a reboot count before another client has read it.",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f06d4f6_c9c80b9c",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-20T18:44:36Z",
      "side": 1,
      "message": "FWIW, I think the purpose of this interface definition is so that we could implement the ManagerDiagnosticData.ResetMetrics action.",
      "parentUuid": "e2ccbc6c_3ef16a21",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21d47fc8_cf274778",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-20T19:21:59Z",
      "side": 1,
      "message": "Do we really want to support that though?  I don\u0027t have context on why DMTF added that action, if I was in the meeting I would\u0027ve argued against it, but from a generalized \"reset all telemetry\" that seems like a bad idea to have?\n\nMy opinion here isn\u0027t that strong if we want to keep it, I just feel like it allows one client to monopolize a set of telemetry, effectively making other callers data useless, which somewhat defeats the open nature of what we\u0027re trying to do.  It might be a difference in requirements between an open bmc stack, and a corporate stack, where there\u0027s likely only one caller into this telemetry.",
      "parentUuid": "8f06d4f6_c9c80b9c",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b1690d3_3bd62eac",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-21T18:32:21Z",
      "side": 1,
      "message": "I would consider this analogous to configuration data as well which can be set by multiple clients.",
      "parentUuid": "21d47fc8_cf274778",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5af408b7_7220db0b",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-21T21:02:30Z",
      "side": 1,
      "message": "\u003e I would consider this analogous to configuration data as well which can be set by multiple clients.\n\nBut.... you can\u0027t have multiple clients resetting a single counter.  I\u0027m confused how that would work?  Would each client have its own counter that could be reset?\n\nTo be clear, the problem becomes:\nCounter increments 0 -\u003e 1.\nClient 1 reads counter.  Counter reads 0.\nClient 1 resets counter.\nClient 2 reads counter, counter reads 0.",
      "parentUuid": "1b1690d3_3bd62eac",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "195be028_f8225487",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-21T21:06:39Z",
      "side": 1,
      "message": "Shoot, I typoed.  Corrected is below.\n\n```\nCounter increments 0 -\u003e 1.\nClient 1 reads counter. Counter reads 1.\nClient 1 resets counter.\nClient 2 reads counter, counter reads 0.\nClient 2 never sees counter increment.\n```",
      "parentUuid": "5af408b7_7220db0b",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "918e0b32_843ffae0",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-26T18:54:20Z",
      "side": 1,
      "message": "I think the question here is about how the manageability is being performed. Is device using multiple client interfaces (for example, ipmi, redfish etc) for communication or a single one. In case, we are using multiple, the same issue is going to be there for configuration flow because a device config being set by one client interface can be reset or over-written by the other. What architecture solution do we have on that front?\n\nPS: I have dropped the reset interface for now.",
      "parentUuid": "195be028_f8225487",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09cd4235_06b966e0",
        "filename": "yaml/xyz/openbmc_project/Metrics/Reset.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 6,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-09-26T21:00:15Z",
      "side": 1,
      "message": "\u003e I think the question here is about how the manageability is being performed. Is device using multiple client interfaces (for example, ipmi, redfish etc) for communication or a single one. In case, we are using multiple, the same issue is going to be there for configuration flow because a device config being set by one client interface can be reset or over-written by the other. What architecture solution do we have on that front?\n\nMultiple interface types effectively look the same as multiple interface clients.  Two users on Redfish look the same as one Redfish user and one IPMI user.\n\nGenerally configuration items have strategies for solving this.  For example, in Redfish, to add a new IP address, you can either specify IfMatch, to ensure that your updates haven\u0027t collided for read-modify-write operations, or use the append/delete syntax to specify an update that isn\u0027t dependent on the current state (Ie, Delete X ip address, rather than update the entire ip address list).  On DBus, generally this is handled by multiple objects, so unless you\u0027re interacting with the same object from two interfaces, it\u0027s pretty tough to actually collide.\n\nAlso, FWIW, the configuration APIs are called probably an order of magnitude less than the monitoring APIs, and only during predominantly during onboarding phases where the clients are well known and isolated in time from one another.\n\n\u003e \n\u003e PS: I have dropped the reset interface for now.\n\nCool.  I think that makes things simpler to separate them, so we can enumerate why the reset api exists, and call out that it\u0027s for implementing the appropriate Redfish APIs.",
      "parentUuid": "918e0b32_843ffae0",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7804ff4_639915f0",
        "filename": "yaml/xyz/openbmc_project/Metrics/Value.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 44,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2023-09-19T21:33:01Z",
      "side": 1,
      "message": "Are you going to follow up with the new constants support in a separate commit?",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9569a0e4_fb507562",
        "filename": "yaml/xyz/openbmc_project/Metrics/Value.interface.yaml",
        "patchSetId": 6
      },
      "lineNbr": 44,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2023-09-19T22:19:14Z",
      "side": 1,
      "message": "Yes, we will make that addition to interface separately. Will float a PR for that.",
      "parentUuid": "b7804ff4_639915f0",
      "revId": "3a148c6fce5f441bbffa81b391cd2faadbb50b21",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}