{
  "comments": [
    {
      "key": {
        "uuid": "d3c918bf_7d2547cc",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2021-02-04T17:53:10Z",
      "side": 1,
      "message": "Say I have I2C8 from ASPEED to a PCA9552 that is on 0061, will this interface return : \n\nBus --\u003e 8\nAddress --\u003e 61 ?",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70b95d21_d77bc55d",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2021-02-04T22:28:59Z",
      "side": 1,
      "message": "I believe the plan was to just put this on object paths where the EEPROMs are so that entity-manager knows what bus it came from so that it can find the other devices on the card.",
      "parentUuid": "d3c918bf_7d2547cc",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fccc66ce_7d7039c3",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000338
      },
      "writtenOn": "2021-02-05T04:16:26Z",
      "side": 1,
      "message": "Yes, the plan is to just do what FruDevice does today and have the EM key off of that data so other apps can write configurations against it. That said, I am not sure how publishing the address of the eeprom is going to help apps that are interested in other devices that the inventory item may have on this I2C bus. So looking for more feedback there.",
      "parentUuid": "70b95d21_d77bc55d",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "578c0296_1e80b8f2",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-16T14:04:18Z",
      "side": 1,
      "message": "Two questions:\n\n1. Isn\u0027t an \"I2CDevice\" a Decorator (I2CAddress maybe?) and not an inventory Item of its own?\n\n2. How are we certain that this bus/address scheme is portable between Linux versions, appropriate for hot-plugged i2c hubs, etc?  Doesn\u0027t Linux assign the bus number in an arbitrary manner?",
      "parentUuid": "fccc66ce_7d7039c3",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5a4f38a_4a84fd31",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000338
      },
      "writtenOn": "2021-02-17T09:27:52Z",
      "side": 1,
      "message": "\u003e Isn\u0027t an \"I2CDevice\" a Decorator (I2CAddress maybe?) and not an inventory Item of its own?\nI tend to agree here, a given inventory item may even have multiple such I2C devices on it. I can change this accordingly, provided we are in agreement about changing the EM code to utilize the new property.\n\n\u003e Doesn\u0027t Linux assign the bus number in an arbitrary manner?\nThis relies on the bus number being explicitly defined in the device tree.",
      "parentUuid": "578c0296_1e80b8f2",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "304057b4_c4d57eaf",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-21T13:19:54Z",
      "side": 1,
      "message": "\u003e This relies on the bus number being explicitly defined in the device tree.\n\nHow does this work for a system that uses something like RunBMC then?  In a design like that you may have a single flash image that supports 5 different machines and then uses EntityManager support to determine what device it is running on, and dynamically bind the downstream i2c hubs.  You\u0027re not going to have i2c information in the device tree because the different machines the RunBMC card plugs into have different structures.",
      "parentUuid": "b5a4f38a_4a84fd31",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93cacc62_b974bd11",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-02-21T17:40:16Z",
      "side": 1,
      "message": "\u003e \u003e This relies on the bus number being explicitly defined in the device tree.\n\u003e \n\u003e How does this work for a system that uses something like RunBMC then?\n\nToday it doesn\u0027t.\n\n\u003e  In a design like that you may have a single flash image that supports 5 different machines and then uses EntityManager support to determine what device it is running on, and dynamically bind the downstream i2c hubs.  You\u0027re not going to have i2c information in the device tree because the different machines the RunBMC card plugs into have different structures.\n\nThe intent when entity-manager was designed was that we could use device tree overlays.  In practice we used them for sensors for a while, but then when beaglebone gave up on their patch to add a userspace dt overlay interface, we moved back to the add_device api for keeping things working with an upstream kernel.  Something like that would be required for runBMC to be able to enable/disable i2c busses at will at runtime.  If I ever have to personally support a runBMC system, that\u0027s what I\u0027d do.\n\nIf someone working on a runBMC system wanted this to work with a single image, we\u0027d likely need to get those beaglebone patches going again in upstream.",
      "parentUuid": "304057b4_c4d57eaf",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}