{
  "comments": [
    {
      "key": {
        "uuid": "862dbe7e_f38c3cc5",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-08T12:01:14Z",
      "side": 1,
      "message": "I think we support \u0027set\u0027.",
      "range": {
        "startLine": 11,
        "startChar": 12,
        "endLine": 11,
        "endChar": 17
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d7b571b_e2d8baa2",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-10T06:34:39Z",
      "side": 1,
      "message": "Hm? What is \"set\"? I didn\u0027t found it in PDI repo.",
      "parentUuid": "862dbe7e_f38c3cc5",
      "range": {
        "startLine": 11,
        "startChar": 12,
        "endLine": 11,
        "endChar": 17
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c9e84b7_8b2bc7a0",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-10T11:38:10Z",
      "side": 1,
      "message": "https://github.com/openbmc/sdbusplus/blob/master/docs/interface.md#containers",
      "parentUuid": "4d7b571b_e2d8baa2",
      "range": {
        "startLine": 11,
        "startChar": 12,
        "endLine": 11,
        "endChar": 17
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8998b1e_4722d616",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-03T20:16:00Z",
      "side": 1,
      "message": "Why is this an array?  Are there drives that support multiples of these?",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8843ef5_3579a302",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-04T08:58:04Z",
      "side": 1,
      "message": "That was Patrick\u0027s suggestion, see above (he had SATA+SAS case in mind).\nIn our case it can be only one of them. BTW, here is how we use it:\nhttps://github.com/YADRO-KNS/obmc-yadro-hardware/blob/master/src/storage/inventory.cpp",
      "parentUuid": "b8998b1e_4722d616",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdab125e_2a7893ee",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-09T22:28:18Z",
      "side": 1,
      "message": "I would\u0027ve expected SAS would just be the enum for sata+sas?  Making this an array makes it a lot harder to build interfaces, as most interfaces tend to treat this as a single enum.  Otherwise, clients need to then read in the array and priority sort it to determine which things you care about, or you have to make assumptions, like only reading the first one.  I\u0027d much prefer this be a single propertly.",
      "parentUuid": "f8843ef5_3579a302",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66348e98_c1a50ca1",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-10T06:34:39Z",
      "side": 1,
      "message": "No so big deal, actually, but I prefer single enum too.\n@Patrick?",
      "parentUuid": "fdab125e_2a7893ee",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77b0c134_2c93dd2f",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-10T11:38:10Z",
      "side": 1,
      "message": "\u003e Otherwise, clients need to then read in the array and priority sort it to determine which things you care about, or you have to make assumptions, like only reading the first one.\n\nThis is exactly why we support std::set though.  I\u0027m surprised there aren\u0027t any already defined.\n\nBetween adding an Unknown enum and using a set, I\u0027d tend to prefer a set.  It is more accurate (SAS+SATA or SATA+NVMe) and I don\u0027t see it as significantly more complex.\n\n(SATA+NVMe is also a common mode for M.2 card).",
      "parentUuid": "66348e98_c1a50ca1",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cab72ed3_69671855",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-10T19:31:06Z",
      "side": 1,
      "message": "\u003e \u003e Otherwise, clients need to then read in the array and priority sort it to determine which things you care about, or you have to make assumptions, like only reading the first one.\n\u003e \n\u003e This is exactly why we support std::set though.  I\u0027m surprised there aren\u0027t any already defined.\n\u003e \n\u003e Between adding an Unknown enum and using a set, I\u0027d tend to prefer a set.  It is more accurate (SAS+SATA or SATA+NVMe) and I don\u0027t see it as significantly more complex.\n\nStd::set doesn\u0027t solve the problem though.  Sure, it\u0027s a set, but in general you\u0027re not checking for inclusion into a set, you\u0027re matching against a specific type, so you can produce the appropriate inventory interface to the user.  With Redfish or IPMI as an example, what if a drive posted that it was both SATA and SAS, which should take precedence?  Any decision the transport makes is wrong to some degree, and would require clients to hardcode in some kind of precedence, which starts to push business logic into the channels.  What if drive is NVMe and SAS?  Again, pushing the precedence into Redfish/IPMI doesn\u0027t help here, and unless I\u0027m missing something, doesn\u0027t add any use cases that exist.\n\nMaking it a single parameter makes it a lot more obvious what it\u0027s trying to convey, and keeps the business logic in the producing daemon where it belongs.\n\n\n\u003e \n\u003e (SATA+NVMe is also a common mode for M.2 card).\n\nit is?  I know there are SATA+NVMe slots, but I didn\u0027t know that a drive itself could be both at the same time.  Is there an example?",
      "parentUuid": "77b0c134_2c93dd2f",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d888616_24e56cd8",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-10T21:06:09Z",
      "side": 1,
      "message": "\u003e What if drive is NVMe and SAS?  Again, pushing the precedence into Redfish/IPMI doesn\u0027t help here, and unless I\u0027m missing something, doesn\u0027t add any use cases that exist.\n\nI feel like fundamentally the problem here is that the property description is \"interfaces supported\" and not \"interface in use\".  If you\u0027re listing the capabilities of the device, which is what Inventory should be, you want to know everything the device is capable of.  Ideally something in State would tell you which is in use, but unfortunately some of those we\u0027ve been putting into Inventory also.\n\nIt doesn\u0027t necessarily seem appropriate to have the Inventory collector decide on precedence either.  If Redfish only has the ability to express one Protocol, that isn\u0027t our fault such that we should weaken our own data model, and yes that decision _should_ be pushed into the Redfish app.  Just like our dbus model isn\u0027t a direction union of everything in Redfish and IPMI, it isn\u0027t an interset either.\n\n\u003e it is?  I know there are SATA+NVMe slots, but I didn\u0027t know that a drive itself could be both at the same time.  Is there an example?\n\nI think you might be right on this that the slot supports both and not the drive.  I thought key B was for SATA and key M was for PCIe-x4 (nvme) and I know I\u0027ve seen B+M M.2 cards, but I guess newer SATA drives just do B+M, while NVMe just does M.\n\n\n---\n\nIf you think that there really aren\u0027t any SAS-only drives and SAS always implies (+SATA), and Redfish only wants one of them for a \"interfaces supported\", then I guess we can downgrade this to a single property.  I still don\u0027t feel it really reflects what we\u0027re advertising in the description.",
      "parentUuid": "cab72ed3_69671855",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e973b33_5d7c766f",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-12T21:56:25Z",
      "side": 1,
      "message": "\u003e \u003e What if drive is NVMe and SAS?  Again, pushing the precedence into Redfish/IPMI doesn\u0027t help here, and unless I\u0027m missing something, doesn\u0027t add any use cases that exist.\n\u003e \n\u003e I feel like fundamentally the problem here is that the property description is \"interfaces supported\" and not \"interface in use\".  If you\u0027re listing the capabilities of the device, which is what Inventory should be, you want to know everything the device is capable of.\n\nI guess that\u0027s the point though.  What are the use cases for drives that are capable of multiple protocols?  Redfish defines it as a single property, IPMI defines it as entity-id, which is singular, and I believe the drive VPD that we\u0027re going to be pulling this data from only supports one \"type\" field (I forget the exact OEM FRU field name).  Why are we adding complexity to something that we don\u0027t have use cases for?\n\n\u003e  Ideally something in State would tell you which is in use, but unfortunately some of those we\u0027ve been putting into Inventory also.\n\u003e \n\u003e It doesn\u0027t necessarily seem appropriate to have the Inventory collector decide on precedence either.\n\nIn the case of a single property, the inventory handler isn\u0027t deciding precedence, it\u0027s simply taking the single property value it got from the VPD and forwarding it onto the interface.  If anything, the drive/manufacturer itself is deciding precedence, if any, which is really where the decision should lie.\n\n\u003e  If Redfish only has the ability to express one Protocol, that isn\u0027t our fault such that we should weaken our own data model, and yes that decision _should_ be pushed into the Redfish app.  Just like our dbus model isn\u0027t a direction union of everything in Redfish and IPMI, it isn\u0027t an interset either.\n\u003e \n\u003e \u003e it is?  I know there are SATA+NVMe slots, but I didn\u0027t know that a drive itself could be both at the same time.  Is there an example?\n\u003e \n\u003e I think you might be right on this that the slot supports both and not the drive.  I thought key B was for SATA and key M was for PCIe-x4 (nvme) and I know I\u0027ve seen B+M M.2 cards, but I guess newer SATA drives just do B+M, while NVMe just does M.\n\nYep, my understanding is that the drive itself is going to be either sata or nvme in terms of this interface definition.\n\n\u003e \n\u003e \n\u003e ---\n\u003e \n\u003e If you think that there really aren\u0027t any SAS-only drives and SAS always implies (+SATA), and Redfish only wants one of them for a \"interfaces supported\", then I guess we can downgrade this to a single property.  I still don\u0027t feel it really reflects what we\u0027re advertising in the description.\n\nThe above would be my preference.  When and if we find a use case for multiple supported interfaces, we could change this to be multiple, but I have a feeling that we\u0027re never going to need it.\n\n\n\nThe one SLIGHT distinction we _might_ make in the future is drives that have a separate sideband interface, so we can know if the sideband is usb or smbus/mctp but in that case I suspect we\u0027ll want to have a separate \"management interface\" property.",
      "parentUuid": "5d888616_24e56cd8",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "417d1e46_7e1a1b07",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-13T13:06:03Z",
      "side": 1,
      "message": "\u003e What are the use cases for drives that are capable of multiple protocols?\n\nI thought I\u0027ve already stated this.  SAS+SATA is a real thing.  As a user, I may want to answer the question: \"can I move this drive from system A to system B?\"  Without knowing if my SAS drive also supports SATA I can\u0027t answer that question.\n\nI would not be surprised if the thing after NVMe ends up with drives that support { NVMe + \"NVMe-next\" } assuming PCIe is still the primary hardware transport protocol at that point, because the vast majority of NVMe disks are fully of firmware to do all the NVMe parts.\n\n\u003e Redfish defines it as a single property.\n\nThe implication here is that Redfish gets everything 100% correct and complete on the first try? ;)\n\n\u003e Why are we adding complexity to something that we don\u0027t have use cases for?\n\nI didn\u0027t think having a `set` was all that complex, but you\u0027ve raised points indicating why it is, especially for Redfish due to the current property definition.\n\n\u003e When and if we find a use case for multiple supported interfaces, we could change this to be multiple, but I have a feeling that we\u0027re never going to need it.\n\nAgain, we need to be clear that \"SAS+SATA\" (hardware) is just \"SAS\" (enum) today.  Maybe we can do that in the comments (ie. something like \"SAS may imply the drive also supports SATA\").  Otherwise, I don\u0027t mind potentially refactoring in the future when/if we need, even though all the hand-coded dbus codes don\u0027t make it especially easy.",
      "parentUuid": "0e973b33_5d7c766f",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82a378ac_030f5b92",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-13T17:11:23Z",
      "side": 1,
      "message": "\u003e \u003e What are the use cases for drives that are capable of multiple protocols?\n\u003e \n\u003e I thought I\u0027ve already stated this.  SAS+SATA is a real thing.  As a user, I may want to answer the question: \"can I move this drive from system A to system B?\"  Without knowing if my SAS drive also supports SATA I can\u0027t answer that question.\n\nOut of curiosity, does anyone actually do it that way in industry?  As a general rule, every system I\u0027ve been in contact with uses model numbers for that, because whether or not the plug fits is rarely descriptive enough to make repair/replace decisions in a fleet.\n\n\u003e \n\u003e I would not be surprised if the thing after NVMe ends up with drives that support { NVMe + \"NVMe-next\" } assuming PCIe is still the primary hardware transport protocol at that point, because the vast majority of NVMe disks are fully of firmware to do all the NVMe parts.\n\nIsn\u0027t that just NVMe versioning?\n\n\u003e \n\u003e \u003e Redfish defines it as a single property.\n\u003e \n\u003e The implication here is that Redfish gets everything 100% correct and complete on the first try? ;)\n\nNo, but they certainly have a lot more hard drive manufacturers and experts in attendance than we do on this patchset.  The implication is that if every standard we plan on implementing has implemented this as a single property, it\u0027s quite possible they know something we don\u0027t, or have intentionally simplified it.\n\n\u003e \n\u003e \u003e Why are we adding complexity to something that we don\u0027t have use cases for?\n\u003e \n\u003e I didn\u0027t think having a `set` was all that complex, but you\u0027ve raised points indicating why it is, especially for Redfish due to the current property definition.\n\u003e \n\u003e \u003e When and if we find a use case for multiple supported interfaces, we could change this to be multiple, but I have a feeling that we\u0027re never going to need it.\n\u003e \n\u003e Again, we need to be clear that \"SAS+SATA\" (hardware) is just \"SAS\" (enum) today.  Maybe we can do that in the comments (ie. something like \"SAS may imply the drive also supports SATA\").\n\nSeems reasonable.\n\n\u003e  Otherwise, I don\u0027t mind potentially refactoring in the future when/if we need, even though all the hand-coded dbus codes don\u0027t make it especially easy.",
      "parentUuid": "417d1e46_7e1a1b07",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5d2cb70f_9e5d4d47",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-14T11:16:53Z",
      "side": 1,
      "message": "\u003e Out of curiosity, does anyone actually do it that way in industry?  As a general rule, every system I\u0027ve been in contact with uses model numbers for that, because whether or not the plug fits is rarely descriptive enough to make repair/replace decisions in a fleet.\n\nI suspect a \"fleet\" likely describes a certain scale where you\u0027re more likely to use model numbers.  I\u0027m expecting someone on the opposite end of the circularity life-cycle is more likely to plug-and-pray and it is those users where I\u0027m more concerned about \"OpenBMC is a pile of junk that always lies to me\" due to their lesser degree of expertise.",
      "parentUuid": "82a378ac_030f5b92",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9289e637_666d3a04",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-15T09:49:19Z",
      "side": 1,
      "message": "Well, am I right that consensus here to go back to single enum value?\nI agree with Ed that we are not going to use multiple values in reasonable future.",
      "parentUuid": "5d2cb70f_9e5d4d47",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edbb6adb_aa3cd556",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-15T13:38:18Z",
      "side": 1,
      "message": "\u003e Well, am I right that consensus here to go back to single enum value?\n\nYes and add \u0027Unknown\u0027.",
      "parentUuid": "9289e637_666d3a04",
      "range": {
        "startLine": 13,
        "startChar": 10,
        "endLine": 13,
        "endChar": 56
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c76eb104_5e0558cb",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-03T20:16:00Z",
      "side": 1,
      "message": "Do we want to have an explicit enumeration for \"Unknown\" such that we can make it very clear the behavior when this interface can\u0027t be implemented, or we don\u0027t have the data in the VPD.",
      "range": {
        "startLine": 21,
        "startChar": 12,
        "endLine": 21,
        "endChar": 26
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3a5c7b8_889648ac",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-04T08:58:04Z",
      "side": 1,
      "message": "Good point! I have comment in commit message: \"Leave the list empty if supported interfaces unknown.\", forgot to add it to parameter description. Will fix.",
      "parentUuid": "c76eb104_5e0558cb",
      "range": {
        "startLine": 21,
        "startChar": 12,
        "endLine": 21,
        "endChar": 26
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cabd63e9_812e945e",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-03T20:16:00Z",
      "side": 1,
      "message": "A USB drive kind of feels like it doesn\u0027t really fit in this abstraction, as it\u0027s not an \"internal drive\" but more of a storage device.  I would expect that something like a flash drive would have its own inventory type, but maybe not?  Is there a use case for this?  Maybe it\u0027s worth omitting until we have a better use case?",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 39,
        "endChar": 37
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "104dbf96_9d27ffbe",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-04T08:58:04Z",
      "side": 1,
      "message": "No, I have no usecases for USB right now, just thought it might be useful later.\nI don\u0027t mind to remove it.\nPatrick, what\u0027s your opinion here?",
      "parentUuid": "cabd63e9_812e945e",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 39,
        "endChar": 37
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9030ebeb_99d0b7d5",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-09-08T12:01:14Z",
      "side": 1,
      "message": "Is \"USB\" even a drive interface?  Isn\u0027t it \"SATA over USB\" or \"SCSI over USB\"?",
      "parentUuid": "104dbf96_9d27ffbe",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 39,
        "endChar": 37
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3c6766b_0efa9e65",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-09-09T22:24:58Z",
      "side": 1,
      "message": "IMO lets just remove it in the context of this patchset.  We\u0027ll deal with it when we have a use case.",
      "parentUuid": "9030ebeb_99d0b7d5",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 39,
        "endChar": 37
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c7c73ae7_bfa6b007",
        "filename": "yaml/xyz/openbmc_project/Inventory/Item/Drive.interface.yaml",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-10T06:34:39Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "f3c6766b_0efa9e65",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 39,
        "endChar": 37
      },
      "revId": "aa52871e1c06a2de352e7217fc371ac12c4fc4ad",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    }
  ]
}