{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "dd34b099_66dbc49e",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-06-10T21:56:46Z",
      "side": 1,
      "message": "It seems like you\u0027re going to add this object onto all of the \"Access\" objects, when switching is allowed?  Or are you always going to have it?  How are you able to determine which set of UARTs are switched with each other (which seems like valuable information).\n\nWould it be useful to have a top-level Console.Manager object, which has an Active property holding an object_path to the active console (of the consoles managed by that manager process)?",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c447736_93ea6844",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-11T01:49:06Z",
      "side": 1,
      "message": "Using \"Control\" in the interface name seems a bit abstract to me and a bit unconstrained. The functionality we\u0027re caring about is supporting muxed consoles. I feel it would be in improvement to constrain the interface to the problem and name it accordingly. Perhaps something with `.Mux` in it, and have it live on a \"manager\" object?",
      "parentUuid": "dd34b099_66dbc49e",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b72df04_ebce1c85",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-11T10:03:35Z",
      "side": 1,
      "message": "The plan was to have this interface present on every console, independent of the presence of a mux.\n\nThat way there does not have to be a check in other projects that want to use this interface to interact with the console. They can simply assume it to always be there.\n\nFor the information about which UARTs are switched with each other, that was exposed in my previous implementation as \"ConflictingConsoleIds\" property. But that implementation was discarded in favor of a single-process solution.\n\nFor the \"Console.Manager\" or similar object, that could be interesting for other software to discover the active console. Using objectmapper to find all the \u0027Active\u0027 properties would work aswell.\n\nI would not want to expose much more information than needed by obmc-console-ctl initially. We can always add more objects, paths and properties later on.\n\n\nFor the \u0027xyz.openbmc_project.Console.Control\u0027 name, i chose it intentionally to not refer to a mux. I wanted it to be abstract enough to not expose that implementation detail to other sw. \n\nThe console could be \"inactive\" due to any number of reasons or states that may be implemented in obmc-console in the future, or it could fail to \"Activate()\" due to these same reasons. The other sw does not need to know the internal reason and could probably not do much about it if it had that information.",
      "parentUuid": "7c447736_93ea6844",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52264e47_7b67f969",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-12T02:01:42Z",
      "side": 1,
      "message": "\u003e That way there does not have to be a check in other projects that want to use this interface to interact with the console. They can simply assume it to always be there.\n\nIMO it\u0027s self-evident that a console that does not have an interposing mux is active. I think presence of the interface adds some unnecessary confusion in the less complex setups.\n\nThe assumption that the interface is always present might sound like it simplifies things, but I\u0027m not sure that has much impact. You\u0027ll still have to handle errors coming back, and invoking a method on an interface that doesn\u0027t exist just another type of error. I don\u0027t think that argument is overly reductive?\n\nBroadly, the presence of an interface presents the existence of a capability. For instance we already [conditionally expose](https://github.com/openbmc/obmc-console/blob/master/console-dbus.c#L189-L199) the [UART interface](https://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Console/UART.interface.yaml), as it\u0027s not meaningful to set a baud rate on a VUART. If setting the active console isn\u0027t meaningful because there\u0027s only one option, then it\u0027s not really the case that there\u0027s a capability to switch.\n\n\u003e For the \u0027xyz.openbmc_project.Console.Control\u0027 name, i chose it intentionally to not refer to a mux. I wanted it to be abstract enough to not expose that implementation detail to other sw.\n\u003e\n\u003e The console could be \"inactive\" due to any number of reasons or states that may be implemented in obmc-console in the future, or it could fail to \"Activate()\" due to these same reasons.\n\nOkay, so considering the future is important. Also important is having the restraint not to implement abstractions that we don\u0027t immediately need so long as we don\u0027t inhibit future development. I\u0027m not saying that the abstraction is unquestionably unnecessary, just I\u0027m not convinced it\u0027s necessary **yet**.\n\nIn the spirit of considering the future, can you enumerate your reasons why the console could be \"inactive\" in support of the `Active` concept and the more abstract `Control` interface?\n\nWhat I\u0027m trying to explore is whether any of them cause a more specific (straw-person) `Mux` interface on some kind of manager object to inhibit the abstraction to a `Control` interface (on a console object) down the track.",
      "parentUuid": "2b72df04_ebce1c85",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4d08e1f_8802d92a",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-12T08:48:49Z",
      "side": 1,
      "message": "The \u0027Mux\u0027 interface on some manager object just exposes implementation details already by it\u0027s name.\nThen we would need to think about some method of how to switch that mux which could take console id as an argument to switch to that Console.\n\nSince the console id is already part of the bus name, i would assume the manager object needs it\u0027s own bus name. Something like\n\nxyz.openbmc_project.Console.Manager\n\nBut then that is not possible with multiple console servers which each have their own mux.\n\nOne could suggest doing something related to the name of the tty device, like\n\nxyz.openbmc_project.Console.TTYS1Manager\n  /xyz/openbmc_project/console/manager\n     xyz.openbmc_project.Console.Mux\n        method   Select(console_id)\n        property Selected (string)\n\nThis is somewhat inconvenient to use since the name of the tty device is exposed, which is configuration detail, and instead of having to just know the name of the console id, the user now also has to know the name of the tty device to use this concept. However this could be made to work, let me know if you prefer.\n\nIn the case of not having a separate dbus name, the Manager needs to be at the path or interface level for each console.\n\nxyz.openbmc_project.Console.console1\n  /xyz/openbmc_project/console/console1\n  /xyz/openbmc_project/console/Manager\n      xyz.openbmc_project.Console.Mux\n\nIn that case this \u0027Manager\u0027 with it\u0027s \u0027Mux\u0027 interface, independent of it\u0027s object path, is already doing what the \u0027xyz.openbmc_project.Console.Control\u0027 interface was doing, just with another name.\n\n\nI can think of a few reasons why having the \u0027Active\u0027 property might be beneficial.\nIn case of a board with multiple UARTs connected to the BMC, this can help bmcweb SOL select which one to show. \n\nLet\u0027s make an example with CPLD, PCH or BIC.\nWhen the host boots, there may be another controller which is printing on it\u0027s UART and it may be interesting to show the output. That UART is \u0027Active\u0027 while the host UART is \u0027Inactive\u0027 at this point. Then later the host uart becomes \u0027Active\u0027 since it\u0027s UART controller has only recently been powered.\n\nIn some cases the \u0027Active\u0027 state could be detected by e.g. powergood or other gpio.\n\nSo we know that there is multiple states for a console\n- uart controller not powered -\u003e console inactive\n- uart controller powered but uart is disconnected by other chip\n  (someone told me there is atleast 1 such board) -\u003e console inactive\n- uart controller powered, connected -\u003e console active\n\nThen there could be other cases in which there is a mux and several uarts behind it and some of them may be available to be activated, since we know the devices they are connected to are powered (via gpio or other info). In that case there could be \u0027Available\u0027 property to indicate that an \u0027Activate\u0027 call could succeed.\nBut that\u0027s out of scope for this change anyways since this is just about a mux.\n\nWhat i\u0027m trying to demonstrate is that \u0027Active\u0027 can have uses beyond mux. \u0027Activate()\u0027 can also be used in the future for other things, taking steps needed to try and connect that console, if that\u0027s switching a mux or setting some gpio value for another device or whatever.\n\n\n\nI just care about a working dbus interface that can accomplish what i need (switch the mux to some console id).\n\nSo since you have the better idea, please paste the interface and how it should look like, with detailed info on \n\n- dbus name\n - object path\n  - interface name\n   - properties\n   - methods\n\nand if it should be conditionally exposed.\n\nThen i can create the new revision and update the documentation + implementation on the obmc-console patches.",
      "parentUuid": "52264e47_7b67f969",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8046bd3_880b76c4",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-14T02:50:05Z",
      "side": 1,
      "message": "Sorry, this is a wall of text, but I feel like I need to work from first principles to clarify my thoughts.\n\n\u003e So since you have the better idea\n\nLet me first say that my intent is for a discussion where we reach consensus on a reasonable approach. I\u0027m not trying to have better ideas than anyone else, much less assert mine are better. I\u0027m trying to consider alternatives and balance trade-offs.\n\nMy starting points are:\n\n1. We already have support for concurrent console server instances\n2. Concurrent console support is implemented as one obmc-console-server process per Linux TTY device\n3. As each Linux TTY device is paired with its obmc-console-server process, each obmc-console-server DBus connection needs a unique name\n4. We use the unique `console-id`s to name global resources, including both the DBus connection and the instance\u0027s unix domain socket.\n5. Currently, each obmc-console-server instance exposes one console via its associated Linux TTY device\n\nThe first impact of muxed consoles is at the final point. Disregarding muxes briefly and restating point 5 above, the current implementation of obmc-console has a `1:1:1` relationship over the `(console, obmc-console-server, TTY)` pieces of the system.\n\nIMO handling muxes needs us to pick between two design points with the following relationships:\n\n1. One obmc-console-server process exposes one muxed console: `N:N:1`\n2. One obmc-console-server process exposes many muxed consoles: `N:1:1`\n\nThe approach you initially proposed is design point 1. In the reviews I\u0027ve been suggesting we also consider design point 2.\n\nMy concern with design point 1 is that it requires a bunch of coordination across multiple processes for resources that don\u0027t handle multiple access very gracefully (primarily GPIOs and TTYs).\n\nBy contrast, design point 2 handles the GPIOs and the TTY in a single process (while exposing multiple consoles), which by definition requires no inter-process coordination for these resources. I think that lifts some concern.\n\nHowever, that leads us to the current ABI of obmc-console-server:\n\n- Each console has a unique DBus connection name, derived from the `console-id`.\n- Each console has a unique object path under its DBus connection, derived from `console-id`\n- Each console has a unique Unix domain socket abstract path, derived from `console-id`.\n\nThis drives another consideration: Because the concurrent consoles feature is implemented as separate obmc-console-server processes, the current implementation has a `1:1:1` relationship between the `(name, connection, process)` properties of the design. We only ever host one console, so there\u0027s no need for multiple names or connections in the process.\n\nChoosing design point 1 above would necessarily maintain this relationship, as it uses further processes to represent the muxed consoles.\n\nAs mentioned in reviews of the other patches, DBus allows us to claim multiple bus names. From [the spec](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus):\n\n\u003e As with interface names, including a version number in well-known bus names is a good idea; it\u0027s possible to have the well-known bus name for more than one version simultaneously if backwards compatibility is required.\n\nDesign point 2 above allows us to choose between a two more options:\n\n1. `N:N:1`: In our one obmc-console-server process we create N connections to represent the N mux legs, and we create 1 bus name for each of the N connections\n2. `N:1:1`: In our one obmc-console-server process we create 1 connection, and request N bus names for it\n\nThe trade-off between these two is that option 1 splits the object tree, while option 2 unifies it: Using any claimed connection name to communicate with the process yields the same object tree as any other claimed connection name.\n\nFurther, option 2 doesn\u0027t have a negative impact on the current DBus ABI - the unified object tree just has more objects in it than would otherwise be expected, but still contains the object at the path expected by current implementations in e.g. bmcweb or phosphor-host-ipmid.\n\nHere\u0027s a gist demonstrating the concept:\n\nhttps://gist.github.com/amboar/4ad0c808ffa3d7b3be0b85d26b7db619\n\nGiven the circumstances where we have a mux as a focal point, I think the second design-point with the second bus connection option is a more natural representation: It gives us one object tree for all consoles behind a mux, and therefore an opportunity for a singular instance of an interface to control the mux in the manner of a \"manager\" object. In essence, we could put a hypothetical `Mux` interface on an object at `/xyz/openbmc_project/console` that controls the mux for all the console objects underneath its path. At this point it\u0027s a bit limited in that the representation suggests a single mux and not a tree of `N` muxes with `N \u003e 1`, but it\u0027s not clear to me that we should be concerned by that. Possibly we could work around it with clever specification of GPIOs in the config and our `mux-index` property anyway.\n\nNow, I still think it\u0027s reasonable that we have an `Active` property on an interface on each individual console object that generates a `PropertiesChanged` signal. This signals to any watchers that the mux has been switched to or away from the console of interest while only watching that console object and without relying on some unspecified in-band text. However, that doesn\u0027t do anything for consumers that didn\u0027t connect via the DBus API either, so I\u0027m yet to form an opinion.\n\n---\n\nSo addressing your request and your broader response:\n\n\u003e please paste the interface and how it should look like, with detailed info on ... and if it should be conditionally exposed.\n\nWith the demo in the gist defining `Mux` as a separate interface on the `/xyz/openbmc_project/console` object it\u0027s easy for it to be conditionally exposed. I think the output in the gist captures the rest of the details of what I\u0027m proposing. Please do be assured that I\u0027m not claiming it\u0027s perfect and can\u0027t be changed in the face of reason, but I consider it a starting point that accounts for my thoughts above. It\u0027s not a directive, and I would like your feedback.\n\n\u003e I can think of a few reasons why having the \u0027Active\u0027 property might be beneficial.\n\nThanks for enumerating your thoughts there. My feeling is exploiting the `Active` property to represent power states of the connected devices is a bridge too far, especially in the face of an `Activate()` method. If `Active` comes to represent power state then it follows that `Activate()` affects power state, and IMO that\u0027s really not something `obmc-console` should be concerned with.\n\n\u003e In the case of not having a separate dbus name, the Manager needs to be at the path or interface level for each console.\n\nI don\u0027t necessarily agree with this, and I\u0027ve set this statement aside in my suggestion above. [The DBus spec says](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus):\n\n\u003e If a well-known bus name implies the presence of a \"main\" interface, that \"main\" interface is often given the same name as the well-known bus name, and situated at the corresponding object path. \n\nIt\u0027s suggesting an idiomatic structure, but it doesn\u0027t require it. Further, if we consider the \"main\" interface to be the `Access` interface for the console then we\u0027re still upholding the spirit of the spec. Just that we locate another interface on a parent object that can control some behaviour of the \"main\" interface.\n\n\u003e Since the console id is already part of the bus name, i would assume the manager object needs it\u0027s own bus name. Something like\n\u003e\n\u003e xyz.openbmc_project.Console.Manager\n\u003e \n\u003e But then that is not possible with multiple console servers which each have their own mux.\n\u003e\n\n\u003e One could suggest doing something related to the name of the tty device, like\n\u003e\n\u003e xyz.openbmc_project.Console.TTYS1Manager\n\u003e ...\n\u003e\n\u003e This is somewhat inconvenient to use since the name of the tty device is exposed, which is configuration detail, and instead of having to just know the name of the console id, the user now also has to know the name of the tty device to use this concept.\n\n\u003e In that case this \u0027Manager\u0027 with it\u0027s \u0027Mux\u0027 interface, independent of it\u0027s object path, is already doing what the \u0027xyz.openbmc_project.Console.Control\u0027 interface was doing, just with another name.\n\nYeah, I agree these approaches are all a bit undesirable. However, what I\u0027ve proposed isn\u0027t any of these and I don\u0027t think suffers from the drawbacks.\n\nI\u0027m interested in your thoughts and apologies again for such a long response.",
      "parentUuid": "f4d08e1f_8802d92a",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "945aa8f0_a20e5c52",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-06-10T21:56:46Z",
      "side": 1,
      "message": "This isn\u0027t C.  Use a dbus error if you have an error to return.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 42
      },
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "853f557b_ce4fe555",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-11T10:03:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "945aa8f0_a20e5c52",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 42
      },
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}