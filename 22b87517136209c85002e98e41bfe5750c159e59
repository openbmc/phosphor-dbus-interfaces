{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d7d13df4_c388de6a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001027
      },
      "writtenOn": "2022-01-20T01:36:15Z",
      "side": 1,
      "message": "Hope these can be merged soon.",
      "revId": "22b87517136209c85002e98e41bfe5750c159e59",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7987baf_95c9eb54",
        "filename": "yaml/xyz/openbmc_project/Software/README.md",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T03:03:23Z",
      "side": 1,
      "message": "The current design is that there can be multiple Activation interfaces from a single Version and those Activation interfaces are hosted at sub-paths.  The primary/secondary flash bank is one such example that is clearly identified here.  The Activation path might be something like `/xyz/openbmc_project/software/12345/bmc-primary` (for well-defined paths we should probably enumerate in this document what the expectations are).\n\nThis is why I don\u0027t understand why we need a new UpdateTarget interface.  There are already separate Activations that tell you which device you are updating.  The advantage of separate Activations is that it also handles other device types (than just dual flash banks of the BMC).  We are already implementing support for multi-host BIOS update (devices might be host-1, host-2, host-3).  You could also handle VRs, CPLDs, Xeon ME, etc. like this.  IMO separate Activation interfaces is far more flexible because it handles _all_ these cases and not just a dual flash BMC.\n\nSince the separate Activation interfaces _can_ handle a dual-flash BMC, like you are proposing, I don\u0027t see a reason to also have a different way to handle it (ie. your UpdateTarget proposal).  This makes additional work for external interfaces, like bmcweb/Redfish, to special case the BMC.",
      "range": {
        "startLine": 55,
        "startChar": 41,
        "endLine": 59,
        "endChar": 79
      },
      "revId": "22b87517136209c85002e98e41bfe5750c159e59",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7818fe97_e14936f4",
        "filename": "yaml/xyz/openbmc_project/Software/README.md",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000044
      },
      "writtenOn": "2022-01-20T05:51:10Z",
      "side": 1,
      "message": "I did not realize this part.\nIs there any existing code that implemented the sub-path already?\n\n\u003e This is why I don\u0027t understand why we need a new UpdateTarget interface. \n\nSay the user uploads a BMC image on a dual image system:\n1. image-manager will create the version interface on /xyz/openbmc_project/software/\u003cid-to-be-updated\u003e;\n2. itme-updater will create the activation/version interface on the same object as well.\nHow does the user tell which BMC slot is to be updated in the above case?\n\nWith the sub-path concept, the item-updater may need to create two activation objects for this:\n /xyz/openbmc_project/software/\u003cid-to-be-updated\u003e/bmc_primary\n /xyz/openbmc_project/software/\u003cid-to-be-updated\u003e/bmc_secondary\n\nIs the above expected?\n\nIf yes, if the user only wants to update the `\u003cid-to-be-updated\u003e/bmc_primary`, the user needs to set RequestedActivation on the `\u003cid-to-be-updated\u003e/bmc_primary` object, and delete the `\u003cid-to-be-updated\u003e/bmc_secondary`, it looks not so good that doing a code update needs to delete a DBus object...\n\nI see it could express the concept of the same image on multiple devices, but it is not clear to me how good it is to handle the code update case.",
      "parentUuid": "a7987baf_95c9eb54",
      "range": {
        "startLine": 55,
        "startChar": 41,
        "endLine": 59,
        "endChar": 79
      },
      "revId": "22b87517136209c85002e98e41bfe5750c159e59",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68dc7719_b45752df",
        "filename": "yaml/xyz/openbmc_project/Software/README.md",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-01-20T17:31:32Z",
      "side": 1,
      "message": "\u003e I did not realize this part.\n\u003e Is there any existing code that implemented the sub-path already?\n\nNo.  Some team members from HCL are working on an implementation for the Yv2 BIOS as an example.  I believe they\u0027re going to do refactoring of phosphor-bmc-code-mgmt as well.\n\nTheir design, which I\u0027m working through with them, is at:\n   https://gerrit.openbmc-project.xyz/c/openbmc/docs/+/37950\n\n\u003e With the sub-path concept, the item-updater may need to create two activation objects for this:\n\u003e  /xyz/openbmc_project/software/\u003cid-to-be-updated\u003e/bmc_primary\n\u003e  /xyz/openbmc_project/software/\u003cid-to-be-updated\u003e/bmc_secondary\n\u003e \n\u003e Is the above expected?\n\nYes, this is exactly what it expected.  The item-updater(s) will create slot/device specific sub-path elements.\n \n\u003e If yes, if the user only wants to update the `\u003cid-to-be-updated\u003e/bmc_primary`, the user needs to set RequestedActivation on the `\u003cid-to-be-updated\u003e/bmc_primary` object, and delete the `\u003cid-to-be-updated\u003e/bmc_secondary`, it looks not so good that doing a code update needs to delete a DBus object...\n\nThe `bmc_secondary` does not get deleted directly, no.  I think you\u0027re asking about the concept of garbage collection.\n\nThe ImageManager currently (as implemented today) keeps the images which could be activated and is responsible for garbage collecting them.  A reboot would usually cause them to be remove automatically since we keep them in tmpfs.  Otherwise there are two options:\n\n1. The ImageManager is already expected to expose a Object.Delete interface to allow proactive garbage collection (removal of the unapplied image).\n\n2. The ImageManager is expected to monitor for all targets to be Activated or Staged and then automatically garbage collect.\n\nBoth of these options are documented here:\nhttps://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Software/README.md#image-clean-up",
      "parentUuid": "7818fe97_e14936f4",
      "range": {
        "startLine": 55,
        "startChar": 41,
        "endLine": 59,
        "endChar": 79
      },
      "revId": "22b87517136209c85002e98e41bfe5750c159e59",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}