{
  "comments": [
    {
      "key": {
        "uuid": "d3c918bf_7d2547cc",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000014
      },
      "writtenOn": "2021-02-04T17:53:10Z",
      "side": 1,
      "message": "Say I have I2C8 from ASPEED to a PCA9552 that is on 0061, will this interface return : \n\nBus --\u003e 8\nAddress --\u003e 61 ?",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70b95d21_d77bc55d",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2021-02-04T22:28:59Z",
      "side": 1,
      "message": "I believe the plan was to just put this on object paths where the EEPROMs are so that entity-manager knows what bus it came from so that it can find the other devices on the card.",
      "parentUuid": "d3c918bf_7d2547cc",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fccc66ce_7d7039c3",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000338
      },
      "writtenOn": "2021-02-05T04:16:26Z",
      "side": 1,
      "message": "Yes, the plan is to just do what FruDevice does today and have the EM key off of that data so other apps can write configurations against it. That said, I am not sure how publishing the address of the eeprom is going to help apps that are interested in other devices that the inventory item may have on this I2C bus. So looking for more feedback there.",
      "parentUuid": "70b95d21_d77bc55d",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "578c0296_1e80b8f2",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-16T14:04:18Z",
      "side": 1,
      "message": "Two questions:\n\n1. Isn\u0027t an \"I2CDevice\" a Decorator (I2CAddress maybe?) and not an inventory Item of its own?\n\n2. How are we certain that this bus/address scheme is portable between Linux versions, appropriate for hot-plugged i2c hubs, etc?  Doesn\u0027t Linux assign the bus number in an arbitrary manner?",
      "parentUuid": "fccc66ce_7d7039c3",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5a4f38a_4a84fd31",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000338
      },
      "writtenOn": "2021-02-17T09:27:52Z",
      "side": 1,
      "message": "\u003e Isn\u0027t an \"I2CDevice\" a Decorator (I2CAddress maybe?) and not an inventory Item of its own?\nI tend to agree here, a given inventory item may even have multiple such I2C devices on it. I can change this accordingly, provided we are in agreement about changing the EM code to utilize the new property.\n\n\u003e Doesn\u0027t Linux assign the bus number in an arbitrary manner?\nThis relies on the bus number being explicitly defined in the device tree.",
      "parentUuid": "578c0296_1e80b8f2",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "304057b4_c4d57eaf",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-21T13:19:54Z",
      "side": 1,
      "message": "\u003e This relies on the bus number being explicitly defined in the device tree.\n\nHow does this work for a system that uses something like RunBMC then?  In a design like that you may have a single flash image that supports 5 different machines and then uses EntityManager support to determine what device it is running on, and dynamically bind the downstream i2c hubs.  You\u0027re not going to have i2c information in the device tree because the different machines the RunBMC card plugs into have different structures.",
      "parentUuid": "b5a4f38a_4a84fd31",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93cacc62_b974bd11",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-02-21T17:40:16Z",
      "side": 1,
      "message": "\u003e \u003e This relies on the bus number being explicitly defined in the device tree.\n\u003e \n\u003e How does this work for a system that uses something like RunBMC then?\n\nToday it doesn\u0027t.\n\n\u003e  In a design like that you may have a single flash image that supports 5 different machines and then uses EntityManager support to determine what device it is running on, and dynamically bind the downstream i2c hubs.  You\u0027re not going to have i2c information in the device tree because the different machines the RunBMC card plugs into have different structures.\n\nThe intent when entity-manager was designed was that we could use device tree overlays.  In practice we used them for sensors for a while, but then when beaglebone gave up on their patch to add a userspace dt overlay interface, we moved back to the add_device api for keeping things working with an upstream kernel.  Something like that would be required for runBMC to be able to enable/disable i2c busses at will at runtime.  If I ever have to personally support a runBMC system, that\u0027s what I\u0027d do.\n\nIf someone working on a runBMC system wanted this to work with a single image, we\u0027d likely need to get those beaglebone patches going again in upstream.",
      "parentUuid": "304057b4_c4d57eaf",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74c2e76b_954c3a1d",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-02-21T17:43:58Z",
      "side": 1,
      "message": "I would note, nothing about this dbus interface precludes making the above work, and having it exist means that people are far less likely to be hardcoding bus numbers in config files, so that when/if we do get dt overlays working again, we should have minimal code to fix in the individual reactors.",
      "parentUuid": "93cacc62_b974bd11",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b813dbfa_f8fafc37",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-21T18:41:25Z",
      "side": 1,
      "message": "The alternative to dt overlays is direct binding calls though, right?  And this won\u0027t work if we go that direction.  So it seems like this interface is forcing us to go a direction that isn\u0027t even supported by the upstream kernel when there is another path that is supported upstream...",
      "parentUuid": "74c2e76b_954c3a1d",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ad26c06_213e02a3",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-02-21T18:53:30Z",
      "side": 1,
      "message": "Direct bindings as in, have a device tree per system?  I\u0027m not quite following what direct binding calls would allow for here.  Can you expand a little?\n\nThe EM code that exists today works with this interface on the mainline kernel, so when you say it \"isn\u0027t even supported by the upstream kernel\" that\u0027s not really true.  We use the add device API, then pass the generated bus and i2c address information to dbus, we\u0027re just limited in the things we can instantiate.  We can\u0027t, for example, turn on root i2c bus 3, but we certainly can instantiate a mux with 4 new busses on bus 3 if it\u0027s already instantiated, then pass that information down the line to other things that might need that info to instantiate, say, a sensor behind that mux.\n\nIf you know how to do this in a simpler, more upstream compatible way, I\u0027m all ears, I\u0027d love to see something easier to digest.",
      "parentUuid": "b813dbfa_f8fafc37",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8bed284_d5f6f86e",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2021-02-21T23:01:55Z",
      "side": 1,
      "message": "By \u0027bind\u0027 I was referring to the sysfs interface. I guess PCIe and USB calls it that but i2c doesn\u0027t.\n\nhttps://www.kernel.org/doc/html/v5.10/i2c/instantiating-devices.html#method-4-instantiate-from-user-space\n\nThere is also \u0027drivers_probe\u0027 UAPI for setting up the engine itself, I think.",
      "parentUuid": "4ad26c06_213e02a3",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5b8bda4_d1f09d5f",
        "filename": "xyz/openbmc_project/Inventory/Item/I2CDevice.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-02-21T23:18:11Z",
      "side": 1,
      "message": "\u003e By \u0027bind\u0027 I was referring to the sysfs interface. I guess PCIe and USB calls it that but i2c doesn\u0027t.\n\u003e \n\u003e https://www.kernel.org/doc/html/v5.10/i2c/instantiating-devices.html#method-4-instantiate-from-user-space\n\nThis API is exactly what this interface is used for today (I mistakenly called it \"add device\" not \"new_device\".  My bad.)\n\nThe dbus interface exists so we can pass along the dynamic runtime-generated bus information about the newly added device to the userspace code responsible for instantiating the dbus interfaces.\n\nIn a perfect world, the bind would be done in the individual reactors, not centralized in EM, so we include all the data to make that possible in the future without breaking this API.  The reasons it\u0027s the way it is now are largely because of using DT overlays in the past, it made more sense to stick all the code for that in one spot.\n \n\u003e \n\u003e There is also \u0027drivers_probe\u0027 UAPI for setting up the engine itself, I think.\n\nI was unaware of this UAPI.  I\u0027ll have to look into what interfaces it provides and see if they\u0027re useful to us.",
      "parentUuid": "d8bed284_d5f6f86e",
      "revId": "d8d8af51111b30e9e6de048ddf9786c2804bb2a9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}