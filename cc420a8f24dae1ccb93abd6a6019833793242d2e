{
  "comments": [
    {
      "key": {
        "uuid": "56c0f65a_da072f2e",
        "filename": "xyz/openbmc_project/MCTP/Endpoint.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 2,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-05-10T11:58:30Z",
      "side": 1,
      "message": "I think some of the detail in the commit message should be described here as well - what typically implements this, and what typically uses this? Also you should mention that the implementer may also implement the UUID D-Bus interface since that is an MCTP specified way to aid identification.\n\nSome of the text here (and the property description below) might be from DSP0236 and it should be fine to just point to that. More relevant here is the why and how. You need to specify details like:\n- when are objects supposed to be created by the implementer (post MCTP discovery?)?\n- does a bridge endpoint need to be specified?\n- one object per discovered endpoint?\n- why are EID and SupportedMessageTypes needed to be implemented?\n- UUID?\n- what should happen if an endpoint goes down?\n- lifetime of the objects\n- is there a well known root path that implementers must know of?\n- what about connected bus type (where applicable)?",
      "revId": "cc420a8f24dae1ccb93abd6a6019833793242d2e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7051373_9e3963a8",
        "filename": "xyz/openbmc_project/MCTP/Endpoint.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 2,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-05-10T12:08:20Z",
      "side": 1,
      "message": "I think you need connected bus type because for a case where an implementation assigns the same EID to two bus paths to an endpoint, the bus type will enable upper layers to pick one (based on speed/redundancy). The \"bus type\" that I\u0027m talking about is \"MCTP physical medium identifiers\" from DSP0239.",
      "parentUuid": "56c0f65a_da072f2e",
      "revId": "cc420a8f24dae1ccb93abd6a6019833793242d2e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58080e28_0f141d90",
        "filename": "xyz/openbmc_project/MCTP/Endpoint.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 2,
      "author": {
        "id": 1000005
      },
      "writtenOn": "2021-05-10T12:42:06Z",
      "side": 1,
      "message": "The destination endpoint described by this interface can be behind a MCTP bridge. The goal is to have upper layer protocol like PLDM abstracted from the MCTP network and topology information.\n\nIf the case is that the BMC has multiple local physical interfaces[1], and the suggestion is that PLDM should be able to specify the interface the MCTP message goes out. My view is that it should be another interface that exposes the possible transport types to upper layer protocols.\n\n[1]https://github.com/openbmc/docs/blob/master/designs/mctp/mctp-kernel.md#structure-interfaces--networks",
      "parentUuid": "a7051373_9e3963a8",
      "revId": "cc420a8f24dae1ccb93abd6a6019833793242d2e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6946327_c25bc2b4",
        "filename": "xyz/openbmc_project/MCTP/Endpoint.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 2,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2021-05-11T00:09:02Z",
      "side": 1,
      "message": "How are you expecting pldmd to send its MCTP messages? It feels like the answer might be \"over D-Bus\" which is not the direction MCTP in OpenBMC is headed.\n\nWhy should mctpd expose a D-Bus implementation of what is effectively the routing table when this can be queried by applications through standard kernel interfaces?\n\nThe MCTP socket API should provide a mechanism for binding a socket to a specific interface on the BMC, which will allow you to route packets directly out that interface. Routing table metrics provide information about which interface is preferred in the face of multiple possible routes.",
      "parentUuid": "58080e28_0f141d90",
      "revId": "cc420a8f24dae1ccb93abd6a6019833793242d2e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1d290985_f393e9e8",
        "filename": "xyz/openbmc_project/MCTP/Endpoint.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 2,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-05-11T07:06:29Z",
      "side": 1,
      "message": "@tom - I\u0027m not sure if your response was to my second comment or first ðŸ˜Š. If it was or the second, I think you\u0027re saying the same thing as me - the transport types needs to be exposed. The interface of course can be another YAML file if that\u0027s what you meant.\n\n@andrew - I don\u0027t see how this d-bus interface implies pldmd will send MCTP messages over D-Bus (it doesn\u0027t say that anywhere). That\u0027s definitely not the intent (and maybe Tom should clarify - see my first comment above). This is more about MCTP discovery, specifically dynamic discovery (PCIe VDM). In the MCTP kernel design, it isn\u0027t clear to me what entity performs discovery and assigns EID, and subsequently how does that entity make that information (all EIDs discovered/configured statically, UUIDs if present, transport types, etc) available to upper layer protocols like PLDM. I don\u0027t think PLDM for eg cares about how a message is routed, so it doesn\u0027t care about the routing table. It cares about what EIDs are present, what are the supported message types, UUIDs, etc.",
      "parentUuid": "f6946327_c25bc2b4",
      "revId": "cc420a8f24dae1ccb93abd6a6019833793242d2e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}