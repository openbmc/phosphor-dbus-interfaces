{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "dd34b099_66dbc49e",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-06-10T21:56:46Z",
      "side": 1,
      "message": "It seems like you\u0027re going to add this object onto all of the \"Access\" objects, when switching is allowed?  Or are you always going to have it?  How are you able to determine which set of UARTs are switched with each other (which seems like valuable information).\n\nWould it be useful to have a top-level Console.Manager object, which has an Active property holding an object_path to the active console (of the consoles managed by that manager process)?",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c447736_93ea6844",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-11T01:49:06Z",
      "side": 1,
      "message": "Using \"Control\" in the interface name seems a bit abstract to me and a bit unconstrained. The functionality we\u0027re caring about is supporting muxed consoles. I feel it would be in improvement to constrain the interface to the problem and name it accordingly. Perhaps something with `.Mux` in it, and have it live on a \"manager\" object?",
      "parentUuid": "dd34b099_66dbc49e",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b72df04_ebce1c85",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-11T10:03:35Z",
      "side": 1,
      "message": "The plan was to have this interface present on every console, independent of the presence of a mux.\n\nThat way there does not have to be a check in other projects that want to use this interface to interact with the console. They can simply assume it to always be there.\n\nFor the information about which UARTs are switched with each other, that was exposed in my previous implementation as \"ConflictingConsoleIds\" property. But that implementation was discarded in favor of a single-process solution.\n\nFor the \"Console.Manager\" or similar object, that could be interesting for other software to discover the active console. Using objectmapper to find all the \u0027Active\u0027 properties would work aswell.\n\nI would not want to expose much more information than needed by obmc-console-ctl initially. We can always add more objects, paths and properties later on.\n\n\nFor the \u0027xyz.openbmc_project.Console.Control\u0027 name, i chose it intentionally to not refer to a mux. I wanted it to be abstract enough to not expose that implementation detail to other sw. \n\nThe console could be \"inactive\" due to any number of reasons or states that may be implemented in obmc-console in the future, or it could fail to \"Activate()\" due to these same reasons. The other sw does not need to know the internal reason and could probably not do much about it if it had that information.",
      "parentUuid": "7c447736_93ea6844",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52264e47_7b67f969",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-06-12T02:01:42Z",
      "side": 1,
      "message": "\u003e That way there does not have to be a check in other projects that want to use this interface to interact with the console. They can simply assume it to always be there.\n\nIMO it\u0027s self-evident that a console that does not have an interposing mux is active. I think presence of the interface adds some unnecessary confusion in the less complex setups.\n\nThe assumption that the interface is always present might sound like it simplifies things, but I\u0027m not sure that has much impact. You\u0027ll still have to handle errors coming back, and invoking a method on an interface that doesn\u0027t exist just another type of error. I don\u0027t think that argument is overly reductive?\n\nBroadly, the presence of an interface presents the existence of a capability. For instance we already [conditionally expose](https://github.com/openbmc/obmc-console/blob/master/console-dbus.c#L189-L199) the [UART interface](https://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Console/UART.interface.yaml), as it\u0027s not meaningful to set a baud rate on a VUART. If setting the active console isn\u0027t meaningful because there\u0027s only one option, then it\u0027s not really the case that there\u0027s a capability to switch.\n\n\u003e For the \u0027xyz.openbmc_project.Console.Control\u0027 name, i chose it intentionally to not refer to a mux. I wanted it to be abstract enough to not expose that implementation detail to other sw.\n\u003e\n\u003e The console could be \"inactive\" due to any number of reasons or states that may be implemented in obmc-console in the future, or it could fail to \"Activate()\" due to these same reasons.\n\nOkay, so considering the future is important. Also important is having the restraint not to implement abstractions that we don\u0027t immediately need so long as we don\u0027t inhibit future development. I\u0027m not saying that the abstraction is unquestionably unnecessary, just I\u0027m not convinced it\u0027s necessary **yet**.\n\nIn the spirit of considering the future, can you enumerate your reasons why the console could be \"inactive\" in support of the `Active` concept and the more abstract `Control` interface?\n\nWhat I\u0027m trying to explore is whether any of them cause a more specific (straw-person) `Mux` interface on some kind of manager object to inhibit the abstraction to a `Control` interface (on a console object) down the track.",
      "parentUuid": "2b72df04_ebce1c85",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4d08e1f_8802d92a",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 1,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-12T08:48:49Z",
      "side": 1,
      "message": "The \u0027Mux\u0027 interface on some manager object just exposes implementation details already by it\u0027s name.\nThen we would need to think about some method of how to switch that mux which could take console id as an argument to switch to that Console.\n\nSince the console id is already part of the bus name, i would assume the manager object needs it\u0027s own bus name. Something like\n\nxyz.openbmc_project.Console.Manager\n\nBut then that is not possible with multiple console servers which each have their own mux.\n\nOne could suggest doing something related to the name of the tty device, like\n\nxyz.openbmc_project.Console.TTYS1Manager\n  /xyz/openbmc_project/console/manager\n     xyz.openbmc_project.Console.Mux\n        method   Select(console_id)\n        property Selected (string)\n\nThis is somewhat inconvenient to use since the name of the tty device is exposed, which is configuration detail, and instead of having to just know the name of the console id, the user now also has to know the name of the tty device to use this concept. However this could be made to work, let me know if you prefer.\n\nIn the case of not having a separate dbus name, the Manager needs to be at the path or interface level for each console.\n\nxyz.openbmc_project.Console.console1\n  /xyz/openbmc_project/console/console1\n  /xyz/openbmc_project/console/Manager\n      xyz.openbmc_project.Console.Mux\n\nIn that case this \u0027Manager\u0027 with it\u0027s \u0027Mux\u0027 interface, independent of it\u0027s object path, is already doing what the \u0027xyz.openbmc_project.Console.Control\u0027 interface was doing, just with another name.\n\n\nI can think of a few reasons why having the \u0027Active\u0027 property might be beneficial.\nIn case of a board with multiple UARTs connected to the BMC, this can help bmcweb SOL select which one to show. \n\nLet\u0027s make an example with CPLD, PCH or BIC.\nWhen the host boots, there may be another controller which is printing on it\u0027s UART and it may be interesting to show the output. That UART is \u0027Active\u0027 while the host UART is \u0027Inactive\u0027 at this point. Then later the host uart becomes \u0027Active\u0027 since it\u0027s UART controller has only recently been powered.\n\nIn some cases the \u0027Active\u0027 state could be detected by e.g. powergood or other gpio.\n\nSo we know that there is multiple states for a console\n- uart controller not powered -\u003e console inactive\n- uart controller powered but uart is disconnected by other chip\n  (someone told me there is atleast 1 such board) -\u003e console inactive\n- uart controller powered, connected -\u003e console active\n\nThen there could be other cases in which there is a mux and several uarts behind it and some of them may be available to be activated, since we know the devices they are connected to are powered (via gpio or other info). In that case there could be \u0027Available\u0027 property to indicate that an \u0027Activate\u0027 call could succeed.\nBut that\u0027s out of scope for this change anyways since this is just about a mux.\n\nWhat i\u0027m trying to demonstrate is that \u0027Active\u0027 can have uses beyond mux. \u0027Activate()\u0027 can also be used in the future for other things, taking steps needed to try and connect that console, if that\u0027s switching a mux or setting some gpio value for another device or whatever.\n\n\n\nI just care about a working dbus interface that can accomplish what i need (switch the mux to some console id).\n\nSo since you have the better idea, please paste the interface and how it should look like, with detailed info on \n\n- dbus name\n - object path\n  - interface name\n   - properties\n   - methods\n\nand if it should be conditionally exposed.\n\nThen i can create the new revision and update the documentation + implementation on the obmc-console patches.",
      "parentUuid": "52264e47_7b67f969",
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "945aa8f0_a20e5c52",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-06-10T21:56:46Z",
      "side": 1,
      "message": "This isn\u0027t C.  Use a dbus error if you have an error to return.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 42
      },
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "853f557b_ce4fe555",
        "filename": "yaml/xyz/openbmc_project/Console/Control.interface.yaml",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2024-06-11T10:03:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "945aa8f0_a20e5c52",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 13,
        "endChar": 42
      },
      "revId": "5b83dafa3af98ae5254def306010a745205a3234",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}