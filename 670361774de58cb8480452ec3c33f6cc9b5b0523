{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bee31ba4_925f94c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-09-30T13:52:23Z",
      "side": 1,
      "message": "Why? Fru-device is an internal interface within entity-manager. \n\nIf we’re going to make this public, by documenting it here, we have to also be willing to make changes to align with the rest of the interfaces. I gave a top level “configuration” tree for unchanged entity-manager interfaces that don’t conform because there are a lot of users and baggage and hoped that we could refactor them. I’ve generally not accepted “well we did this thing outside of the process and now we want to document it” interface proposals otherwise.",
      "revId": "670361774de58cb8480452ec3c33f6cc9b5b0523",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3984ec7e_3898082f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-30T14:35:31Z",
      "side": 1,
      "message": "\u003e Why? Fru-device is an internal interface within entity-manager. \n\nWrong. `ipmid`, `intel-ipmi-oem`, `fb-ipmi-oem`, `ampere-ipmi-oem` all use the `GetRawFru` method.\n\nhttps://github.com/search?q\u003dorg%3Aopenbmc+%22GetRawFru%22\u0026type\u003dcode\n\nFor `ReScanBus` it is mostly meta platforms who use it as part of scripts\n\nhttps://github.com/search?q\u003dorg%3Aopenbmc+%22ReScanBus%22\u0026type\u003dcode\n\n\u003e I’ve generally not accepted “well we did this thing outside of the process and now we want to document it” interface proposals otherwise.\n\nIf you do not review ongoing works then of course people will be free-wheeling their way through your design intent.\n\nIf it\u0027s merged, it\u0027s part of openbmc. It\u0027s not a proposal. It\u0027s an existing interface.\n\nAnd if we do not document it, how are folks going to consume it with PDI.\n\nSo person A worked outside the process, person B refuses to document existing interfaces, \n\nand now person C is stuck without the tooling support and must hand-code everything without a generated client.\n\n#### precedence and guiding examples\n\nYou can also think about it this way. People usually find some code which registers a method on an interface and then they copy that to define a new method.\n\nIf we establish a pattern whereby we at least get the interface name, object path namespace and such from PDI, it becomes clear that interfaces and their methods and properties are defined in the PDI.\n\nIf we refuse to document existing stuff, we reinforce the pattern of folks doing things outside of PDI because that\u0027s what they find in the code.",
      "parentUuid": "bee31ba4_925f94c4",
      "revId": "670361774de58cb8480452ec3c33f6cc9b5b0523",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "039a957e_9f70b89a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-09-30T15:07:17Z",
      "side": 1,
      "message": "\u003e If you do not review ongoing works then of course people will be free-wheeling their way through your design intent.\n\nIs there a problem you\u0027re alluding to?  fru-device was written long ago now when a whole company did a lot of \"freewheeling\".\n\n\u003e So person A worked outside the process, person B refuses to document existing interfaces, and now person C is stuck without the tooling support and must hand-code everything without a generated client.\n\nI don\u0027t see how \"person B\" is the one to blame in this?  Alternatively if I just let whatever in, why bother with having reviews here?  Why bother with having any process?  Doesn\u0027t that just encourage people to do their own thing?\n\nUltimately \"Person A\" is the one to blame; unfortunately they\u0027re not around any more.  That means \"Person B\" and \"Person C\" have to clean up the mess.  Are you willing to do the interface definition and refactoring?\n\n\u003e If we refuse to document existing stuff, we reinforce the pattern of folks doing things outside of PDI because that\u0027s what they find in the code.\n\nWe also reinforce a pattern of not following process.",
      "parentUuid": "3984ec7e_3898082f",
      "revId": "670361774de58cb8480452ec3c33f6cc9b5b0523",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "583f989c_f300890d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-30T15:59:53Z",
      "side": 1,
      "message": "\u003e I don\u0027t see how \"person B\" is the one to blame in this? Alternatively if I just let whatever in, why bother with having reviews here? Why bother with having any process? Doesn\u0027t that just encourage people to do their own thing?\n\nI do not want to blame anyone here, but if the point of PDI is to interact with dbus interfaces then it does not work if some interfaces are somehow exempt from it for non technical reason.\nLet\u0027s not make life hard for person C.\n\nThat\u0027s just another argument people then use to say they do not want the PDI in their repo since it does not even support my_special_interface.\n\n#### ongoing works\n\n\u003e Alternatively if I just let whatever in, why bother with having reviews here?\n\nCurrently the `WriteFruFromFile` method is in review and already got two +1.\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/83992\n\nThe review about the interface should happen when the interface is added, right?\n\n#### halfsies\n\nHaving the review at a later point makes it so that there are two reviews and then we end up with half-way support of something.\n\nNow where the interface is added first, PDI or in the reactor, that\u0027s a question between maintainers. That\u0027s something to clear in ToF.\n\n\n#### process\n\n\u003e We also reinforce a pattern of not following process.\n\nIf maintainers are not capable to follow project design intent then project is already doomed. Since project is not (yet) doomed i hope they can follow. \n\nMaintainers are *in their own category* and *should be aware of project design intent*.\n\nBut with help and support for existing interfaces it should be easier to follow,\nespecially for people new to the project who base their contributions around existing code.\n\n\u003e We also reinforce a pattern of not following process.\n\nMost people who go around the PDI are not usually the ones who push for PDI adoption. They do not necessarily have something to gain from this support since they do not use the PDI anyways.\n\n#### no intent to re-design a working interface\n\n\u003e Are you willing to do the interface definition and refactoring?\n\nI want to support the existing interfaces in PDI, to the extent that they can be supported (may be limitations due to usage of variant).\n\nIf the existing interfaces cannot be supported in PDI then it will be hard to introduce PDI into existing asio reactors as the maintainers will not see a use-case in adding a dependency and refactoring external interfaces just to add such dependency.\n\nI do *NOT* want to refactor dbus methods with 10s of upstream and probably 100s of downstream callers just for a re-design of a method which is already functional and working today.\n\nI\u0027m aware it is probably in the wrong namespace and should likely not be toplevel interface.\n\nBut that\u0027s how it is defined.\n\n#### PDI role in refactoring\n\nWithout PDI, dependency of a repo on a specific interface is only discovered at runtime, if you are lucky, you can grep for it.\n\nWith PDI, the refactoring and estimating scope of work becomes easier.\n\nSo if anyone in the future wants to refactor `xyz.openbmc_project.FruDeviceManager` into something else, it will be easier to have all the callers use PDI since\na simple build will expose what will break.\n\nBreaking the build is also a good way to communicate any interface changes to downstream.\n\nSo if the project goes \n\npdi interface -\u003e refactoring -\u003e solution\n\nit should be less breakage than\n\nrefactoring -\u003e pdi interface -\u003e solution",
      "parentUuid": "039a957e_9f70b89a",
      "revId": "670361774de58cb8480452ec3c33f6cc9b5b0523",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}