{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "219a29b5_c985c6d1",
        "filename": "yaml/xyz/openbmc_project/Attestation/ComponentIntegrity.interface.yaml",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2026-01-28T09:59:57Z",
      "side": 1,
      "message": "Could you clarify how this is expected to be updated and what the flow will be for creating a secure session?\n\nMy understanding is as follows:\n- Any application on the BMC that requires a secure MCTP session:\n\n- The initiator (PLDM, SPDM, or a proprietary protocol over MCTP) initiates the secure session setup\n\n- The responder assigns a Session ID\n\n- The secure session becomes active\n\nAre we expecting the initiator(PLDM, SPDM, or a proprietary protocol over MCTP) to create, update, and delete the secure session via the D-Bus object hosted by the SPDM service?\n\nWhat exactly do we gain by hosting this information in the SPDM D-Bus object?\n\nDo we need to show it through OOB that how many secure sessions are active?",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 51,
        "endChar": 19
      },
      "revId": "0ef809ef9a613b61b571b228d5451c86f294a9c7",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cb2c3647_7b7742c6",
        "filename": "yaml/xyz/openbmc_project/Attestation/ComponentIntegrity.interface.yaml",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2026-01-28T15:21:06Z",
      "side": 1,
      "message": "Per the SPDM specification, secure sessions are created internally by the SPDM protocol flow itself if both the requester and responder supports the mutual authentication. Once attestation is complete and mutual trust is established, the requester and responder may use key-exchange commands(if the security policy has `SecureSessionEnabled` enabled) to create a secure session.\n\n\u003e The responder assigns a Session ID\n\n\nNo, Per SPDM specification during the KEY_EXCHANGE or PSK_EXCHANGE sequence, both endpoints contribute to the Session ID: the Requester provides a 2-byte ReqSessionID, the Responder provides a 2-byte RspSessionID, and the final 4-byte Session ID is formed by concatenating the two. Session creation, uniqueness, and teardown are therefore fully owned by the SPDM state machine and not by D-Bus or management clients - hence it is marked as readonly in this patch. \n\n\n\u003e Are we expecting the initiator(PLDM, SPDM, or a proprietary protocol \nover MCTP) to create, update, and delete the secure session via the \nD-Bus object hosted by the SPDM service?\n\n\n\nNope, The application data carried over an SPDM secure session is intentionally out of scope for this change. As defined by the SPDM specification, application data exchanged within a secure session can be arbitrary and vendor-specific, and may include PLDM or other protocols layered on top of SPDM.This change does not introduce any design or mechanism for handling, routing, or interpreting application data over the secure session. It is purely an informational update that exposes the existence of active SPDM secure sessions (session ID and type) for visibility purposes to redfish clients.Any discussion around using secure sessions for PLDM or other application data would be a separate design and change.\n\n\u003e Do we need to show it through OOB that how many secure sessions are active?\n\nWell, that\u0027s a specification question . Redfish supports exposing it. External redfish clients would need to know if there is a secure channel created \u0026 if so how many \u0026 what was the type of authentication used to create the session. That\u0027s what this patch set enables us to do.",
      "parentUuid": "219a29b5_c985c6d1",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 51,
        "endChar": 19
      },
      "revId": "0ef809ef9a613b61b571b228d5451c86f294a9c7",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb1165c6_45a554d8",
        "filename": "yaml/xyz/openbmc_project/Attestation/ComponentIntegrity.interface.yaml",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000022
      },
      "writtenOn": "2026-02-04T07:30:59Z",
      "side": 1,
      "message": "\u003eWell, that\u0027s a specification question . Redfish supports exposing it. External redfish clients would need to know if there is a secure channel created \u0026 if so how many \u0026 what was the type of authentication used to create the session. That\u0027s what this patch set enables us to do.\n\nCurrent use case which you are putting is to create the secure session from spdm client(bmc)and get the attesttaion data over secure session that works fine, Let\u0027s go one step down\n\nMy question is about how secure sessions are represented when multiple daemons use MCTP Type 6 communication.\n\nIf, in the future, any daemon communicating over MCTP requires Type 6 and therefore establishes an SPDM secure session, and if that session is created by the SPDM daemon, will the object implementing the Component Integrity interface (provided by spdmd) maintain and expose all active secure sessions? \n\nAlternatively, is this interface expected to be implemented by each individual application (for example, PLDM, MCTP VDM, or NSM – NVIDIA proprietary protocol), with Redfish aggregating session information from all services that implement this interface?\n\nThis property is being defined as read-only, which means other clients cannot update it with their own session information. This implies that the expected design is either:\n\nEach client D-Bus service (for example, PLDM, MCTP VDM, NSM, etc.) implements the Component Integrity interface and exposes its own secure session information, or\n\nwe should have seprate interface to host the secure seeion realted info.",
      "parentUuid": "cb2c3647_7b7742c6",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 51,
        "endChar": 19
      },
      "revId": "0ef809ef9a613b61b571b228d5451c86f294a9c7",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f21b6cdc_339c48ac",
        "filename": "yaml/xyz/openbmc_project/Attestation/ComponentIntegrity.interface.yaml",
        "patchSetId": 5
      },
      "lineNbr": 51,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2026-02-18T09:07:54Z",
      "side": 1,
      "message": "\u003e My question is about how secure sessions are represented when multiple daemons use MCTP Type 6 communication.\n\n\u003e \n\nI guess this needs a design document of its own since its much bigger topic than what this commit is trying to do.\n\n\u003e If, in the future, any daemon communicating over MCTP requires Type 6 and therefore establishes an SPDM secure session, and if that session is created by the SPDM daemon, will the object implementing the Component Integrity interface (provided by spdmd) maintain and expose all active secure sessions? \n\n\u003e \n\nYes, I think so. Since the secure sessions are handled by the SPDM daemon, it should be hosting the session information irrespective of who is sending data across that channel. \n\n\u003e Alternatively, is this interface expected to be implemented by each individual application (for example, PLDM, MCTP VDM, or NSM – NVIDIA proprietary protocol), with Redfish aggregating session information from all services that implement this interface?\n\n\u003e \n\nNo , i would not expect any other daemon to be hosting the component Integrity information. Rather I expect the SPDM daemon probably should have additonal interface(s) exposed through which pldm/mctp vdm/nsm daemon would route their packets via the secure channel (if need be).\n\n\u003e This property is being defined as read-only, which means other clients cannot update it with their own session information. This implies that the expected design is either:\n\u003e \n\u003e Each client D-Bus service (for example, PLDM, MCTP VDM, NSM, etc.) implements the Component Integrity interface and exposes its own secure session information, or\n\u003e \n\n\u003e we should have seprate interface to host the secure session related info.\n\n\nIMO (this is just a raw thought) -  I don\u0027t think any other daemon in the BMC should be hosting the component Integrity since that is purely tied to the SPDM protocol semantics internally. Rather SPDM should have additional interfaces through which it can route the traffic of other daemons, so spdm daemon will purely be acting as a conduit for other communication daemons.",
      "parentUuid": "fb1165c6_45a554d8",
      "range": {
        "startLine": 41,
        "startChar": 0,
        "endLine": 51,
        "endChar": 19
      },
      "revId": "0ef809ef9a613b61b571b228d5451c86f294a9c7",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}