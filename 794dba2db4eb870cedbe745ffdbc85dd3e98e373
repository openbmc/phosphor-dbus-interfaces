{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ec31ab38_a86a7646",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 15,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-04-03T21:39:11Z",
      "side": 1,
      "message": "What is \"SBMR\"?  I think that is an ARM thing?  How did Ampere do the post codes?",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f2761362_237348d1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 15,
      "author": {
        "id": 1001127
      },
      "writtenOn": "2024-04-05T14:25:38Z",
      "side": 1,
      "message": "Per my experience, Ampere uses 4-byte POST code instead of SBMR, 9-byte POST code; Nvidia uses 9-byte POST code, but the modifications are not opened/upstreamed.",
      "parentUuid": "ec31ab38_a86a7646",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ef33b4c_83a253aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-03-29T18:11:36Z",
      "side": 1,
      "message": "I think the concept of a primary and secondary code was introduced by IBM for their architecture.",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "022be888_41670093",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2024-03-30T05:39:51Z",
      "side": 1,
      "message": "There was a reason why the post codes was changed to the struct.\n\nPlease follow the mailing list trail to understand why : https://lore.kernel.org/openbmc/4795347F-477D-45EF-A145-0C7B163FE01B@getmailspring.com/\n\n\nand also this https://github.com/openbmc/phosphor-dbus-interfaces/commit/9a96970ebb93eb1f495c200801343a4d1c53977c commit message explains the reason why this change was done.",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2ceb415a_5d951a99",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001127
      },
      "writtenOn": "2024-03-30T11:00:18Z",
      "side": 1,
      "message": "Thank you for sharing the history. I have one question, is uint64_t necessary if the byte array can already accommodate the entire post code? Additionally, there\u0027s a slight drawback to storing postcodes primarily in uint64_t. When displayed in Redfish, some codes might not be clearly distinguishable as 1-byte, 4-byte, or longer codes. For example, 0x00000001 might be displayed as 0x01.\n\nActually, the motivation is to display postcode exceed 8 bytes in Redfish (e.g. 9-byte code used in SBMR):\nhttps://gerrit.openbmc.org/c/openbmc/bmcweb/+/70163\n\nThanks!",
      "parentUuid": "022be888_41670093",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3d6915b9_8b7481c4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2024-04-02T11:12:44Z",
      "side": 1,
      "message": "\u003e Thank you for sharing the history. I have one question, is uint64_t necessary if the byte array can already accommodate the entire post code?\n\nYes, that was necessary for IBM to align with the community. IBM post codes aka progress codes are 70 byte long. But some where in those 70 bytes there is an 8byte ascii convertible code that we wanted to display in GUI. Which is why we copied 8 byte content into primary post code and then sticked the entire 70 byte data into the secondary post code, which can be pulled by external client via a redfish attachment on the log resource. Most of the platforms like intel , does not use the secondary post code at all.\n\n\u003e Additionally, there\u0027s a slight drawback to storing postcodes primarily in uint64_t. When displayed in Redfish, some codes might not be clearly distinguishable as 1-byte, 4-byte, or longer codes. For example, 0x00000001 might be displayed as 0x01.\n\u003e \n\nis this a problem ? I guess intel have a byte long post code, where only the Least significant byte gets filled, but redfish still shows 64bit version of it. They don\u0027t seem to have any problem with it. Is this some sort of customer requirement on your platform ?\n\n\u003e Actually, the motivation is to display postcode exceed 8 bytes in Redfish (e.g. 9-byte code used in SBMR):\n\u003e https://gerrit.openbmc.org/c/openbmc/bmcweb/+/70163\n\u003e \n\nYeah, looking at the bmcweb patch. Having a meson option to switch between primary  \u0026 secondary post codes in bmcweb does not seem like the right way to go. bmcweb is just supposed to obtain data from dbus and publish that in redfish. What ever solution that you come up with should be coming from the back end daemons like phosphor-post-code-manager or phosphor-host-postd daemons making sure that none of the other platforms leveraging these repo are broken.\n\n\u003e Thanks!",
      "parentUuid": "2ceb415a_5d951a99",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c41d4a3c_7be60bd7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001127
      },
      "writtenOn": "2024-04-03T03:48:25Z",
      "side": 1,
      "message": "To accommodate a 9-byte or longer code, consider adjusting the uint64_t portion, how about modifying the interface to \"struct[array[byte],array[byte]]\". Updates to phosphor-post-code-manager, phosphor-host-postd, and bmcweb would be necessary.",
      "parentUuid": "3d6915b9_8b7481c4",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "708dc2d8_cb24e0ad",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-04-03T21:39:11Z",
      "side": 1,
      "message": "Can we unwind... what are we trying to accomplish at the high level?  I don\u0027t really understand why parsing of what should be a string in the bmcweb LogService implementation for Post Codes matters and why that should affect the dbus interface.",
      "parentUuid": "c41d4a3c_7be60bd7",
      "revId": "794dba2db4eb870cedbe745ffdbc85dd3e98e373",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}