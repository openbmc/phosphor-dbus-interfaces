{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "85c58df6_a3355553",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-03-29T01:46:52Z",
      "side": 1,
      "message": "\u003e Patch Set 2:\n\u003e \n\u003e I see we have an empty CpuCore interface already, but I don\u0027t really see a utility for it when we don\u0027t have any attributes and we already have Cpu\u0027s property CoreCount (and ThreadCount).  Why do we need to individually enumerate each core and thread in the Inventory model, distinctly from the generic counts provided? \n\u003e \n\u003e The original CpuCore interface was added back in 2016 (\"Add inventory interfaces for OpenBMC\") and we don\u0027t currently have any real users of it (https://github.com/search?q\u003dorg%3Aopenbmc+CpuCore\u0026type\u003dcode).  It seems like it should be removed and not add CpuThread unless you can describe a concrete workflow that utilizes it.\n\u003e \n\u003e Large systems in this generation are going to have almost 2k threads.  That seems to be a potential problem for us to represent all of those on dbus if there isn\u0027t a practical purpose and without any properties I don\u0027t see a strong purpose.\n\nTurns out, we would like to have the option of representing individual threads, as thread level subprocessor is better defined in DMTF/Redfish https://github.com/DMTF/Redfish/issues/5008.\n\nI would like to bump this for review.",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "423d7034_529d7080",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-03-29T04:53:29Z",
      "side": 1,
      "message": "How do you intend to solve the scaling concerns?\n\nCan we add properties onto Cpu or CpuCore to get the same information available for Redfish?  Do we really need/want 2k dbus objects just to represent threads?",
      "parentUuid": "85c58df6_a3355553",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de629984_80f63c6a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-03-30T20:27:24Z",
      "side": 1,
      "message": "Apologies for the late response - was stuck in meetings all day yesterday and didn\u0027t get back to this.\n\nWould it be possible to get a reference of where we would see ~2k threads (if it\u0027s not under NDA or what not)? We currently have many sensor objects and are able to handle them fine with GetManagedObjects (and they are probably more complicated than the simple / small thread dbus-objects). \n\nAs mentioned in another comment from earlier - we have to map the micrcode information at the thread level granularity. Do you have suggestions on how we would do that if we don\u0027t have this thread level d-bus interface?",
      "parentUuid": "423d7034_529d7080",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57f283ef_02495825",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-03-31T02:22:40Z",
      "side": 1,
      "message": "\u003e Would it be possible to get a reference of where we would see ~2k threads (if it\u0027s not under NDA or what not)? \n\nThe IBM E1080 has 1920 threads per https://www.ibm.com/downloads/cas/MMOYB4YL .\n\n\u003e Do you have suggestions on how we would do that if we don\u0027t have this thread level d-bus interface?\n\nIf you really have per-thread microcode information, I think the best bet to minimize scaling is some kind of interface on a socket basis that contains the thread information you need in a structure of some sort.\n\nmap[string , set[size]] which maps \"microcode version\" -\u003e set of thread_id seems like it would be the most efficient.  If we pick something like array[string] or map[size, string] the dbus property itself is going to become so large that I think it\u0027ll be fairly slow on its own, especially for applications which use the XML interfaces for introspection.",
      "parentUuid": "de629984_80f63c6a",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03bf4e51_df5f53aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-03-31T23:04:14Z",
      "side": 1,
      "message": "Thank you for giving me the datasheet for a possible system that has that many threads.\n\nAlthough I believe you\u0027re aware, this is just the context for this change:\n\nWe are hoping to have Micrcode information per thread level granularity in D-Bus for BMCWeb to expose over Redfish. The reason why Microcode information at thread level is important is because there may be some errors with a core / thread where some threads are at a different Microcode version than all others.\n\nWith `map[string , set[size]]`, I guess we would \"expect\" the map should have 1 entry for 1 microcode -\u003e threads (which bmcweb then would be in charge of creating the thread object), but if there\u0027s a problematic case, we would have 2 (or more) key-value pairs in the map that maps the different microcode that some other threads may have.\n\nLet me know if my understanding is correct. Thanks!",
      "parentUuid": "57f283ef_02495825",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}