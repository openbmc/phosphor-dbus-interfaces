{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "85c58df6_a3355553",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-03-29T01:46:52Z",
      "side": 1,
      "message": "\u003e Patch Set 2:\n\u003e \n\u003e I see we have an empty CpuCore interface already, but I don\u0027t really see a utility for it when we don\u0027t have any attributes and we already have Cpu\u0027s property CoreCount (and ThreadCount).  Why do we need to individually enumerate each core and thread in the Inventory model, distinctly from the generic counts provided? \n\u003e \n\u003e The original CpuCore interface was added back in 2016 (\"Add inventory interfaces for OpenBMC\") and we don\u0027t currently have any real users of it (https://github.com/search?q\u003dorg%3Aopenbmc+CpuCore\u0026type\u003dcode).  It seems like it should be removed and not add CpuThread unless you can describe a concrete workflow that utilizes it.\n\u003e \n\u003e Large systems in this generation are going to have almost 2k threads.  That seems to be a potential problem for us to represent all of those on dbus if there isn\u0027t a practical purpose and without any properties I don\u0027t see a strong purpose.\n\nTurns out, we would like to have the option of representing individual threads, as thread level subprocessor is better defined in DMTF/Redfish https://github.com/DMTF/Redfish/issues/5008.\n\nI would like to bump this for review.",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "423d7034_529d7080",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-03-29T04:53:29Z",
      "side": 1,
      "message": "How do you intend to solve the scaling concerns?\n\nCan we add properties onto Cpu or CpuCore to get the same information available for Redfish?  Do we really need/want 2k dbus objects just to represent threads?",
      "parentUuid": "85c58df6_a3355553",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de629984_80f63c6a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-03-30T20:27:24Z",
      "side": 1,
      "message": "Apologies for the late response - was stuck in meetings all day yesterday and didn\u0027t get back to this.\n\nWould it be possible to get a reference of where we would see ~2k threads (if it\u0027s not under NDA or what not)? We currently have many sensor objects and are able to handle them fine with GetManagedObjects (and they are probably more complicated than the simple / small thread dbus-objects). \n\nAs mentioned in another comment from earlier - we have to map the micrcode information at the thread level granularity. Do you have suggestions on how we would do that if we don\u0027t have this thread level d-bus interface?",
      "parentUuid": "423d7034_529d7080",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57f283ef_02495825",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-03-31T02:22:40Z",
      "side": 1,
      "message": "\u003e Would it be possible to get a reference of where we would see ~2k threads (if it\u0027s not under NDA or what not)? \n\nThe IBM E1080 has 1920 threads per https://www.ibm.com/downloads/cas/MMOYB4YL .\n\n\u003e Do you have suggestions on how we would do that if we don\u0027t have this thread level d-bus interface?\n\nIf you really have per-thread microcode information, I think the best bet to minimize scaling is some kind of interface on a socket basis that contains the thread information you need in a structure of some sort.\n\nmap[string , set[size]] which maps \"microcode version\" -\u003e set of thread_id seems like it would be the most efficient.  If we pick something like array[string] or map[size, string] the dbus property itself is going to become so large that I think it\u0027ll be fairly slow on its own, especially for applications which use the XML interfaces for introspection.",
      "parentUuid": "de629984_80f63c6a",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03bf4e51_df5f53aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-03-31T23:04:14Z",
      "side": 1,
      "message": "Thank you for giving me the datasheet for a possible system that has that many threads.\n\nAlthough I believe you\u0027re aware, this is just the context for this change:\n\nWe are hoping to have Micrcode information per thread level granularity in D-Bus for BMCWeb to expose over Redfish. The reason why Microcode information at thread level is important is because there may be some errors with a core / thread where some threads are at a different Microcode version than all others.\n\nWith `map[string , set[size]]`, I guess we would \"expect\" the map should have 1 entry for 1 microcode -\u003e threads (which bmcweb then would be in charge of creating the thread object), but if there\u0027s a problematic case, we would have 2 (or more) key-value pairs in the map that maps the different microcode that some other threads may have.\n\nLet me know if my understanding is correct. Thanks!",
      "parentUuid": "57f283ef_02495825",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ddf58de_3ea58314",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-04-01T11:52:10Z",
      "side": 1,
      "message": "\u003e With `map[string , set[size]]`, I guess we would \"expect\" the map should have 1 entry for 1 microcode -\u003e threads (which bmcweb then would be in charge of creating the thread object), but if there\u0027s a problematic case, we would have 2 (or more) key-value pairs in the map that maps the different microcode that some other threads may have.\n\nI\u0027m not really understanding what you\u0027re asking; it feels like you\u0027re saying \"there might be bugs\".  There _can_ be bugs in any data arrangement, can\u0027t there?\n\nIf you do it as map[size, string] you can be certain each thread-id only has a single string associated with it, but it\u0027s still going to be a really big dbus property (since would expect tons of duplication in the micrcode version).\n\nIf you really wanted to be succinct you could do `map[string, set[pair[size,size]]]` where the pair is a range of thread-ids (or maybe you could even flip the map around in that case with the pairs being the keys).  In the typical case you\u0027re going to end up with a single entry of `[\"version A\" -\u003e [ [0, 239] ]`.",
      "parentUuid": "03bf4e51_df5f53aa",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9c62631_fe82e3c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-04-01T18:34:16Z",
      "side": 1,
      "message": "Just to be clear - I was talking about \"bugs / problematic case\" where all the threads are not reporting the same microcode, either due to them actually being different OR them reporting the microcode wrongly.\n\nSo yes, we EXPECT all threads to have the same microcode, so your idea of having `[\"version A\" -\u003e [ [0, 239] ]`. would be the most succinct way to capture all the threads to micrcode. I guess mapping it to bmcweb could be tricky.. let me see if Ed could ring in to this discussion since in the end, the threads will have to expose through bmcweb.\n\nNoting, we have the same thing at the core level currently (cores report microcode). Do you propose we change the core dbus as well? Otherwise, could it make sense to have this dbus interface as an optional one that people could use if their core / thread count isn\u0027t very large (in the thousands) and the map could be used as an alternative for when there is a very large number (or would duplication cause issues).",
      "parentUuid": "6ddf58de_3ea58314",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10c94a98_c470e329",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-04-01T19:40:17Z",
      "side": 1,
      "message": "\u003e Just to be clear - I was talking about \"bugs / problematic case\" where all the threads are not reporting the same microcode, either due to them actually being different OR them reporting the microcode wrongly.\n\nThis in itself doesn\u0027t seem like a problem; that\u0027s why it is a map.  What is a problem is if an implementation has an internal bug like [ \"version A\" -\u003e [ 1 ], \"version B\" -\u003e [ 1 ] ].  Doing a map[size_t, string] prevents this kind of bug, but it\u0027s just a bug and should be fixed if it is discovered.\n\n\u003e Noting, we have the same thing at the core level currently (cores report microcode). Do you propose we change the core dbus as well?\n\nConsidering this is currently the only information in CpuCore, I\u0027d tend to say we should remove that interface and do per-socket microcode information:\n\n    /.../socket_0/microcode/cores\n    /.../socket_0/microcode/threads\n\n(or microcode_cores could be workable)\n\nWe don\u0027t have as much scaling issues on cores, but we might as well make the interrogation consistent.\n\n\u003e Otherwise, could it make sense to have this dbus interface as an optional one that people could use if their core / thread count isn\u0027t very large \n\nI don\u0027t think we want two ways to present the same information.  That just makes it more expensive to consume in applications like bmcweb because they have to implement both and we\u0027re going to end up with 2 different companies that prefer one over the other and one of the implementations will be broken half the time.",
      "parentUuid": "e9c62631_fe82e3c0",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4301a88d_e717c9aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-05-03T20:28:09Z",
      "side": 1,
      "message": "About a month ago, we finalized on \"I think the map of version to set of threads is the most simple solution\"\n\nhttps://discord.com/channels/775381525260664832/960653386523488296/961015043514834955\n\nI\u0027m thinking again about how this will look like from the BMCWeb side - when we try to enumerate .../Processors/cpu0/SubProcessors/core0/SubProcessors, how would we able to list that there are \"thread0\" and \"thread1\" under core0 ?",
      "parentUuid": "10c94a98_c470e329",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c13fac0_c7f612f0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-05-04T20:53:01Z",
      "side": 1,
      "message": "Hmm, looks like that link didn\u0027t work. It\u0027s a thread named \"phoshpor-dbus-interface for thread level microcode information\" under #bmcweb-and-redfish channel",
      "parentUuid": "4301a88d_e717c9aa",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8f6f93e_9d4e3394",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-07-15T16:29:45Z",
      "side": 1,
      "message": "Just wanted to revive this review - Nikhil has worked on the bmcweb side change on how the threads DBus object would be used to expose it on bmcweb (which is what will use this DBus object): https://gerrit.openbmc.org/c/openbmc/bmcweb/+/54900\n\nBecause we have to expose what subprocessors are available for each core and each threads may even have ProcessorMetrics attached to them - I believe we need a per thread DBus object.",
      "parentUuid": "7c13fac0_c7f612f0",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f29020c_15b1f9d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-08-03T17:33:27Z",
      "side": 1,
      "message": "Gentle ping on this",
      "parentUuid": "e8f6f93e_9d4e3394",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "809e87b6_0d03c81c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000388
      },
      "writtenOn": "2022-08-11T17:53:22Z",
      "side": 1,
      "message": "Ping on this threads PDI review",
      "parentUuid": "2f29020c_15b1f9d2",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50432f5a_d747ef77",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2022-10-05T11:28:08Z",
      "side": 1,
      "message": "\u003e I\u0027m thinking again about how this will look like from the BMCWeb side - when we try to enumerate .../Processors/cpu0/SubProcessors/core0/SubProcessors, how would we able to list that there are \"thread0\" and \"thread1\" under core0 ?\n\nI don\u0027t see any effort to solve the scaling issues with this commit.\n\nThere is an architecture for inventory associations now and I have documented rules for them here: https://gerrit.openbmc.org/c/openbmc/phosphor-dbus-interfaces/+/57604\n\nPlease see if associations help you solve the interrogation issues.",
      "parentUuid": "809e87b6_0d03c81c",
      "revId": "7dcf6ea402a86bf4b0306cfa0a4bdfa56aa603b2",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}